Index: cmake/VA_COPY.cmake
===================================================================
--- cmake/VA_COPY.cmake	(revision 0)
+++ cmake/VA_COPY.cmake	(revision 0)
@@ -0,0 +1,42 @@
+MACRO(VA_COPY)
+    write_file("${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/cmake_try_compile.c"
+    "#include <stdarg.h>
+    void f (int i, ...) {
+        va_list args1, args2;
+        va_start (args1, i);
+        va_copy (args2, args1);
+        if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+            exit (1);
+        va_end (args1); va_end (args2);
+    }
+    int main() {
+        f (0, 42);
+        return 0;
+    }
+    ")
+    try_compile(HAVE_VA_COPY ${CMAKE_BINARY_DIR} ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/cmake_try_compile.c)
+
+    if(HAVE_VA_COPY)
+        SET(VA_COPY va_copy CACHE STRING "va_copy function")
+    else()
+        write_file("${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/cmake_try_compile.c"
+        "#include <stdarg.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            __va_copy (args2, args1);
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }
+        int main() {
+            f (0, 42);
+            return 0;
+        }
+        ")
+        try_compile(HAVE_VA_COPY ${CMAKE_BINARY_DIR} ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/cmake_try_compile.c)
+        if(HAVE___VA_COPY)
+            SET(_VA_COPY __va_copy CACHE STRING "va_copy function")
+        endif()
+    endif()
+ENDMACRO()
Index: cmake/FortranCInterface/my_sub.f
===================================================================
--- cmake/FortranCInterface/my_sub.f	(revision 0)
+++ cmake/FortranCInterface/my_sub.f	(revision 0)
@@ -0,0 +1,2 @@
+      subroutine my_sub
+      end
Index: cmake/FortranCInterface/Input.cmake.in
===================================================================
--- cmake/FortranCInterface/Input.cmake.in	(revision 0)
+++ cmake/FortranCInterface/Input.cmake.in	(revision 0)
@@ -0,0 +1,3 @@
+set(CMAKE_Fortran_COMPILER_ID "@CMAKE_Fortran_COMPILER_ID@")
+set(FortranCInterface_GLOBAL_SYMBOLS "@FortranCInterface_GLOBAL_SYMBOLS@")
+set(FortranCInterface_MODULE_SYMBOLS "@FortranCInterface_MODULE_SYMBOLS@")
Index: cmake/FortranCInterface/mysub.f
===================================================================
--- cmake/FortranCInterface/mysub.f	(revision 0)
+++ cmake/FortranCInterface/mysub.f	(revision 0)
@@ -0,0 +1,2 @@
+      subroutine mysub
+      end
Index: cmake/FortranCInterface/Output.cmake.in
===================================================================
--- cmake/FortranCInterface/Output.cmake.in	(revision 0)
+++ cmake/FortranCInterface/Output.cmake.in	(revision 0)
@@ -0,0 +1,33 @@
+# Global symbol without underscore.
+set(FortranCInterface_GLOBAL_SYMBOL  "@FortranCInterface_GLOBAL_SYMBOL@")
+set(FortranCInterface_GLOBAL_PREFIX  "@FortranCInterface_GLOBAL_PREFIX@")
+set(FortranCInterface_GLOBAL_SUFFIX  "@FortranCInterface_GLOBAL_SUFFIX@")
+set(FortranCInterface_GLOBAL_CASE    "@FortranCInterface_GLOBAL_CASE@")
+set(FortranCInterface_GLOBAL_MACRO   "@FortranCInterface_GLOBAL_MACRO@")
+
+# Global symbol with underscore.
+set(FortranCInterface_GLOBAL__SYMBOL "@FortranCInterface_GLOBAL__SYMBOL@")
+set(FortranCInterface_GLOBAL__PREFIX "@FortranCInterface_GLOBAL__PREFIX@")
+set(FortranCInterface_GLOBAL__SUFFIX "@FortranCInterface_GLOBAL__SUFFIX@")
+set(FortranCInterface_GLOBAL__CASE   "@FortranCInterface_GLOBAL__CASE@")
+set(FortranCInterface_GLOBAL__MACRO  "@FortranCInterface_GLOBAL__MACRO@")
+
+# Module symbol without underscore.
+set(FortranCInterface_MODULE_SYMBOL  "@FortranCInterface_MODULE_SYMBOL@")
+set(FortranCInterface_MODULE_PREFIX  "@FortranCInterface_MODULE_PREFIX@")
+set(FortranCInterface_MODULE_MIDDLE  "@FortranCInterface_MODULE_MIDDLE@")
+set(FortranCInterface_MODULE_SUFFIX  "@FortranCInterface_MODULE_SUFFIX@")
+set(FortranCInterface_MODULE_CASE    "@FortranCInterface_MODULE_CASE@")
+set(FortranCInterface_MODULE_MACRO   "@FortranCInterface_MODULE_MACRO@")
+
+# Module symbol with underscore.
+set(FortranCInterface_MODULE__SYMBOL "@FortranCInterface_MODULE__SYMBOL@")
+set(FortranCInterface_MODULE__PREFIX "@FortranCInterface_MODULE__PREFIX@")
+set(FortranCInterface_MODULE__MIDDLE "@FortranCInterface_MODULE__MIDDLE@")
+set(FortranCInterface_MODULE__SUFFIX "@FortranCInterface_MODULE__SUFFIX@")
+set(FortranCInterface_MODULE__CASE   "@FortranCInterface_MODULE__CASE@")
+set(FortranCInterface_MODULE__MACRO  "@FortranCInterface_MODULE__MACRO@")
+
+# Summarize what was found.
+set(FortranCInterface_GLOBAL_FOUND @FortranCInterface_GLOBAL_FOUND@)
+set(FortranCInterface_MODULE_FOUND @FortranCInterface_MODULE_FOUND@)
Index: cmake/FortranCInterface/Detect.cmake
===================================================================
--- cmake/FortranCInterface/Detect.cmake	(revision 0)
+++ cmake/FortranCInterface/Detect.cmake	(revision 0)
@@ -0,0 +1,123 @@
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+
+include(CreateOutput)
+
+configure_file(${FortranCInterface_SOURCE_DIR}/Input.cmake.in
+               ${FortranCInterface_BINARY_DIR}/Input.cmake @ONLY)
+
+# Detect the Fortran/C interface on the first run or when the
+# configuration changes.
+if(${FortranCInterface_BINARY_DIR}/Input.cmake
+    IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+    OR ${FortranCInterface_SOURCE_DIR}/Output.cmake.in
+    IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+    OR ${FortranCInterface_SOURCE_DIR}/CMakeLists.txt
+    IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+    OR ${CMAKE_CURRENT_LIST_FILE}
+    IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+    )
+  message(STATUS "Detecting Fortran/C Interface")
+else()
+  return()
+endif()
+
+# Invalidate verification results.
+unset(FortranCInterface_VERIFIED_C CACHE)
+unset(FortranCInterface_VERIFIED_CXX CACHE)
+
+set(_result)
+
+# Build a sample project which reports symbols.
+try_compile(FortranCInterface_COMPILED
+  ${FortranCInterface_BINARY_DIR}
+  ${FortranCInterface_SOURCE_DIR}
+  FortranCInterface
+  CMAKE_FLAGS
+    "-DCMAKE_C_FLAGS:STRING=${CMAKE_C_FLAGS}"
+    "-DCMAKE_Fortran_FLAGS:STRING=${CMAKE_Fortran_FLAGS}"
+  OUTPUT_VARIABLE FortranCInterface_OUTPUT)
+set(FortranCInterface_COMPILED ${FortranCInterface_COMPILED})
+unset(FortranCInterface_COMPILED CACHE)
+
+# Locate the sample project executable.
+if(FortranCInterface_COMPILED)
+  find_program(FortranCInterface_EXE
+    NAMES FortranCInterface
+    PATHS ${FortranCInterface_BINARY_DIR} ${FortranCInterface_BINARY_DIR}/Debug
+    NO_DEFAULT_PATH
+    )
+  set(FortranCInterface_EXE ${FortranCInterface_EXE})
+  unset(FortranCInterface_EXE CACHE)
+else()
+  set(_result "Failed to compile")
+  set(FortranCInterface_EXE)
+  file(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log
+    "Fortran/C interface test project failed with the following output:\n"
+    "${FortranCInterface_OUTPUT}\n")
+endif()
+
+# Load symbols from INFO:symbol[] strings in the executable.
+set(FortranCInterface_SYMBOLS)
+if(FortranCInterface_EXE)
+  file(STRINGS "${FortranCInterface_EXE}" _info_strings
+    LIMIT_COUNT 8 REGEX "INFO:[^[]*\\[")
+  foreach(info ${_info_strings})
+    if("${info}" MATCHES ".*INFO:symbol\\[([^]]*)\\].*")
+      string(REGEX REPLACE ".*INFO:symbol\\[([^]]*)\\].*" "\\1" symbol "${info}")
+      list(APPEND FortranCInterface_SYMBOLS ${symbol})
+    endif()
+  endforeach()
+elseif(NOT _result)
+  set(_result "Failed to load sample executable")
+endif()
+
+set(_case_mysub "LOWER")
+set(_case_my_sub "LOWER")
+set(_case_MYSUB "UPPER")
+set(_case_MY_SUB "UPPER")
+set(_global_regex  "^(_*)(mysub|MYSUB)([_$]*)$")
+set(_global__regex "^(_*)(my_sub|MY_SUB)([_$]*)$")
+set(_module_regex  "^(_*)(mymodule|MYMODULE)([A-Za-z_$]*)(mysub|MYSUB)([_$]*)$")
+set(_module__regex "^(_*)(my_module|MY_MODULE)([A-Za-z_$]*)(my_sub|MY_SUB)([_$]*)$")
+
+# Parse the symbol names.
+foreach(symbol ${FortranCInterface_SYMBOLS})
+  foreach(form "" "_")
+    # Look for global symbols.
+    string(REGEX REPLACE "${_global_${form}regex}"
+                         "\\1;\\2;\\3" pieces "${symbol}")
+    list(LENGTH pieces len)
+    if(len EQUAL 3)
+      set(FortranCInterface_GLOBAL_${form}SYMBOL "${symbol}")
+      list(GET pieces 0 FortranCInterface_GLOBAL_${form}PREFIX)
+      list(GET pieces 1 name)
+      list(GET pieces 2 FortranCInterface_GLOBAL_${form}SUFFIX)
+      set(FortranCInterface_GLOBAL_${form}CASE "${_case_${name}}")
+    endif()
+
+    # Look for module symbols.
+    string(REGEX REPLACE "${_module_${form}regex}"
+                         "\\1;\\2;\\3;\\4;\\5" pieces "${symbol}")
+    list(LENGTH pieces len)
+    if(len EQUAL 5)
+      set(FortranCInterface_MODULE_${form}SYMBOL "${symbol}")
+      list(GET pieces 0 FortranCInterface_MODULE_${form}PREFIX)
+      list(GET pieces 1 module)
+      list(GET pieces 2 FortranCInterface_MODULE_${form}MIDDLE)
+      list(GET pieces 3 name)
+      list(GET pieces 4 FortranCInterface_MODULE_${form}SUFFIX)
+      set(FortranCInterface_MODULE_${form}CASE "${_case_${name}}")
+    endif()
+  endforeach()
+endforeach()
+
+CreateCFortranOutput()
Index: cmake/FortranCInterface/my_module.f90
===================================================================
--- cmake/FortranCInterface/my_module.f90	(revision 0)
+++ cmake/FortranCInterface/my_module.f90	(revision 0)
@@ -0,0 +1,8 @@
+module my_module
+  interface my_interface
+     module procedure my_sub
+  end interface
+contains
+  subroutine my_sub
+  end subroutine my_sub
+end module my_module
Index: cmake/FortranCInterface/mymodule.f90
===================================================================
--- cmake/FortranCInterface/mymodule.f90	(revision 0)
+++ cmake/FortranCInterface/mymodule.f90	(revision 0)
@@ -0,0 +1,8 @@
+module mymodule
+  interface myinterface
+     module procedure mysub
+  end interface
+contains
+  subroutine mysub
+  end subroutine mysub
+end module mymodule
Index: cmake/FortranCInterface/symbol.c.in
===================================================================
--- cmake/FortranCInterface/symbol.c.in	(revision 0)
+++ cmake/FortranCInterface/symbol.c.in	(revision 0)
@@ -0,0 +1,4 @@
+const char* @symbol@(void)
+{
+  return "INFO:symbol[@symbol@]";
+}
Index: cmake/FortranCInterface/Macro.h.in
===================================================================
--- cmake/FortranCInterface/Macro.h.in	(revision 0)
+++ cmake/FortranCInterface/Macro.h.in	(revision 0)
@@ -0,0 +1,4 @@
+#ifndef @MACRO_NAMESPACE@HEADER_INCLUDED
+#define @MACRO_NAMESPACE@HEADER_INCLUDED
+@HEADER_CONTENT@
+#endif
Index: cmake/FortranCInterface/DetectFromLibrary.cmake
===================================================================
--- cmake/FortranCInterface/DetectFromLibrary.cmake	(revision 0)
+++ cmake/FortranCInterface/DetectFromLibrary.cmake	(revision 0)
@@ -0,0 +1,86 @@
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+
+include(CheckLibraryExists)
+include(CreateOutput)
+
+function(detect_fortran_function libname library func)
+
+#  configure_file(${FortranCInterface_SOURCE_DIR}/Input.cmake.in
+#                 ${FortranCInterface_BINARY_DIR}/Input.cmake @ONLY)
+
+#  # Detect the Fortran/C interface on the first run or when the
+#  # configuration changes.
+#  if(${FortranCInterface_BINARY_DIR}/Input.cmake
+#      IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+#      OR ${FortranCInterface_SOURCE_DIR}/Output.cmake.in
+#      IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+#      OR ${FortranCInterface_SOURCE_DIR}/CMakeLists.txt
+#      IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+#      OR ${CMAKE_CURRENT_LIST_FILE}
+#      IS_NEWER_THAN ${FortranCInterface_BINARY_DIR}/Output.cmake
+#      )
+#    message(STATUS "Detecting Fortran/C Interface")
+#  else()
+#    return()
+#  endif()
+
+  # Invalidate verification results.
+  unset(FortranCInterface_VERIFIED_C CACHE)
+  unset(FortranCInterface_VERIFIED_CXX CACHE)
+
+  # Detect the underscore/non underscore functions.
+
+  string(REGEX MATCH "^.*_.*$" output ${func})
+  if ("${output}" STREQUAL ${func})
+    set(form "_")
+  else()
+    set(form "")
+  endif()
+
+  # Detect global/module functions.
+
+  string(REGEX MATCH "^.*:.*$" output ${func})
+  if ("${output}" STREQUAL ${func})
+    # How to deal with with MIDDLE ??
+    MESSAGE(WARNING "Modules not fully implemented yet!!")
+    set(type "MODULE")
+  else()
+    set(type "GLOBAL")
+  endif()
+
+  string(TOUPPER "${func}" subup)
+  string(TOLOWER "${func}" sublo)
+  foreach(suffix "_" "")
+    foreach(base ${subup} ${sublo})
+      foreach(prefix "" "_" "__")
+        set(symbol "${prefix}${base}${suffix}")
+        set(doc "function")
+        message(STATUS "checking Fortran ${doc} linkage: ${symbol}")
+        unset(worked CACHE)
+        check_library_exists(${library} ${symbol} "" worked)
+        if(worked)
+          message(STATUS "found Fortran function linkage")
+          set(FortranCInterface_${type}_${form}SYMBOL "${symbol}" PARENT_SCOPE)
+          set(FortranCInterface_${type}_${form}PREFIX "${prefix}" PARENT_SCOPE)
+          set(FortranCInterface_${type}_${form}SUFFIX "${suffix}" PARENT_SCOPE)
+          if (${base} STREQUAL ${subup})
+              set(FortranCInterface_${type}_${form}CASE "UPPER" PARENT_SCOPE)
+          else()
+              set(FortranCInterface_${type}_${form}CASE "LOWER" PARENT_SCOPE)
+          endif()
+          return()
+        endif()
+      endforeach()
+    endforeach()
+  endforeach()
+  MESSAGE(ERROR "Function ${func} cannot be found in library ${libname}")
+endfunction()
Index: cmake/FortranCInterface/CreateOutput.cmake
===================================================================
--- cmake/FortranCInterface/CreateOutput.cmake	(revision 0)
+++ cmake/FortranCInterface/CreateOutput.cmake	(revision 0)
@@ -0,0 +1,65 @@
+macro(CreateCFortranOutput)
+  # Construct mangling macro definitions.
+  set(_name_LOWER "name")
+  set(_name_UPPER "NAME")
+  foreach(form "" "_")
+    if(FortranCInterface_GLOBAL_${form}SYMBOL)
+      if(FortranCInterface_GLOBAL_${form}PREFIX)
+        set(_prefix "${FortranCInterface_GLOBAL_${form}PREFIX}##")
+      else()
+        set(_prefix "")
+      endif()
+      if(FortranCInterface_GLOBAL_${form}SUFFIX)
+        set(_suffix "##${FortranCInterface_GLOBAL_${form}SUFFIX}")
+      else()
+        set(_suffix "")
+      endif()
+      set(_name "${_name_${FortranCInterface_GLOBAL_${form}CASE}}")
+      set(FortranCInterface_GLOBAL${form}_MACRO
+        "(name,NAME) ${_prefix}${_name}${_suffix}")
+    endif()
+    if(FortranCInterface_MODULE_${form}SYMBOL)
+      if(FortranCInterface_MODULE_${form}PREFIX)
+        set(_prefix "${FortranCInterface_MODULE_${form}PREFIX}##")
+      else()
+        set(_prefix "")
+      endif()
+      if(FortranCInterface_MODULE_${form}SUFFIX)
+        set(_suffix "##${FortranCInterface_MODULE_${form}SUFFIX}")
+      else()
+        set(_suffix "")
+      endif()
+      set(_name "${_name_${FortranCInterface_MODULE_${form}CASE}}")
+      set(_middle "##${FortranCInterface_MODULE_${form}MIDDLE}##")
+      set(FortranCInterface_MODULE${form}_MACRO
+        "(mod_name,name, mod_NAME,NAME) ${_prefix}mod_${_name}${_middle}${_name}${_suffix}")
+    endif()
+  endforeach()
+
+  # Summarize what is available.
+  foreach(scope GLOBAL MODULE)
+    if(FortranCInterface_${scope}_SYMBOL AND
+        FortranCInterface_${scope}__SYMBOL)
+      set(FortranCInterface_${scope}_FOUND 1)
+    else()
+      set(FortranCInterface_${scope}_FOUND 0)
+    endif()
+  endforeach()
+
+  # Record the detection results.
+  configure_file(${FortranCInterface_SOURCE_DIR}/Output.cmake.in
+                 ${FortranCInterface_BINARY_DIR}/Output.cmake @ONLY)
+  file(APPEND ${FortranCInterface_BINARY_DIR}/Output.cmake "\n")
+
+  # Report the results.
+  if(FortranCInterface_GLOBAL_FOUND)
+    if(FortranCInterface_MODULE_FOUND)
+      set(_result "Found GLOBAL and MODULE mangling")
+    else(FortranCInterface_MODULE_FOUND)
+      set(_result "Found GLOBAL but not MODULE mangling")
+    endif()
+  elseif(NOT _result)
+    set(_result "Failed to recognize symbols")
+  endif()
+  message(STATUS "Detecting Fortran/C Interface - ${_result}")
+endmacro()
Index: cmake/FortranCInterface/Verify/VerifyFortran.f
===================================================================
--- cmake/FortranCInterface/Verify/VerifyFortran.f	(revision 0)
+++ cmake/FortranCInterface/Verify/VerifyFortran.f	(revision 0)
@@ -0,0 +1,3 @@
+      subroutine VerifyFortran
+        print *, 'VerifyFortran'
+      end
Index: cmake/FortranCInterface/Verify/main.c
===================================================================
--- cmake/FortranCInterface/Verify/main.c	(revision 0)
+++ cmake/FortranCInterface/Verify/main.c	(revision 0)
@@ -0,0 +1,16 @@
+extern void VerifyC(void);
+#ifdef VERIFY_CXX
+extern void VerifyCXX(void);
+#endif
+#include "VerifyFortran.h"
+extern void VerifyFortran(void);
+
+int main(void)
+{
+  VerifyC();
+#ifdef VERIFY_CXX
+  VerifyCXX();
+#endif
+  VerifyFortran();
+  return 0;
+}
Index: cmake/FortranCInterface/Verify/VerifyCXX.cxx
===================================================================
--- cmake/FortranCInterface/Verify/VerifyCXX.cxx	(revision 0)
+++ cmake/FortranCInterface/Verify/VerifyCXX.cxx	(revision 0)
@@ -0,0 +1,4 @@
+extern "C" void VerifyCXX(void)
+{
+  delete new int;
+}
Index: cmake/FortranCInterface/Verify/VerifyC.c
===================================================================
--- cmake/FortranCInterface/Verify/VerifyC.c	(revision 0)
+++ cmake/FortranCInterface/Verify/VerifyC.c	(revision 0)
@@ -0,0 +1,5 @@
+#include <stdio.h>
+void VerifyC(void)
+{
+  printf("VerifyC\n");
+}
Index: cmake/FortranCInterface/Verify/CMakeLists.txt
===================================================================
--- cmake/FortranCInterface/Verify/CMakeLists.txt	(revision 0)
+++ cmake/FortranCInterface/Verify/CMakeLists.txt	(revision 0)
@@ -0,0 +1,32 @@
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+
+cmake_minimum_required(VERSION 2.7)
+project(VerifyFortranC C Fortran)
+
+option(VERIFY_CXX "Whether to verify C++ and Fortran" OFF)
+if(VERIFY_CXX)
+  enable_language(CXX)
+  set(VerifyCXX VerifyCXX.cxx)
+  add_definitions(-DVERIFY_CXX)
+endif()
+
+include(FortranCInterface)
+
+FortranCInterface_HEADER(VerifyFortran.h SYMBOLS VerifyFortran)
+include_directories(${VerifyFortranC_BINARY_DIR})
+
+add_executable(VerifyFortranC main.c VerifyC.c VerifyFortran.f ${VerifyCXX})
+
+if(NOT VERIFY_CXX)
+  # The entry point (main) is defined in C; link with the C compiler.
+  set_property(TARGET VerifyFortranC PROPERTY LINKER_LANGUAGE C)
+endif()
Index: cmake/FortranCInterface/call_mod.f90
===================================================================
--- cmake/FortranCInterface/call_mod.f90	(revision 0)
+++ cmake/FortranCInterface/call_mod.f90	(revision 0)
@@ -0,0 +1,6 @@
+subroutine call_mod
+  use mymodule
+  use my_module
+  call mysub()
+  call my_sub()
+end subroutine call_mod
Index: cmake/FortranCInterface/call_sub.f
===================================================================
--- cmake/FortranCInterface/call_sub.f	(revision 0)
+++ cmake/FortranCInterface/call_sub.f	(revision 0)
@@ -0,0 +1,4 @@
+        subroutine call_sub
+          call mysub()
+          call my_sub()
+        end
Index: cmake/FortranCInterface/main.F
===================================================================
--- cmake/FortranCInterface/main.F	(revision 0)
+++ cmake/FortranCInterface/main.F	(revision 0)
@@ -0,0 +1,6 @@
+        program main
+          call call_sub()
+#ifdef CALL_MOD
+          call call_mod()
+#endif
+        end
Index: cmake/FortranCInterface/my_module_.c
===================================================================
--- cmake/FortranCInterface/my_module_.c	(revision 0)
+++ cmake/FortranCInterface/my_module_.c	(revision 0)
@@ -0,0 +1,8 @@
+#if defined(__PATHSCALE__)
+/* PathScale Fortran wants my_module_ when calling any my_module symbol,
+   but module symbols use '.in.' so we cannot provide them anyway.  */
+void pathscale_my_module_(void) {}
+#else
+/* PGI Fortran wants my_module_ when calling any my_module symbol.  */
+void my_module_(void) {}
+#endif
Index: cmake/FortranCInterface/mymodule_.c
===================================================================
--- cmake/FortranCInterface/mymodule_.c	(revision 0)
+++ cmake/FortranCInterface/mymodule_.c	(revision 0)
@@ -0,0 +1,8 @@
+#if defined(__PATHSCALE__)
+/* PathScale Fortran wants mymodule_ when calling any mymodule symbol,
+   but module symbols use '.in.' so we cannot provide them anyway.  */
+void pathscale_mymodule_(void) {}
+#else
+/* PGI Fortran wants mymodule_ when calling any mymodule symbol.  */
+void mymodule_(void) {}
+#endif
Index: cmake/FortranCInterface/CMakeLists.txt
===================================================================
--- cmake/FortranCInterface/CMakeLists.txt	(revision 0)
+++ cmake/FortranCInterface/CMakeLists.txt	(revision 0)
@@ -0,0 +1,95 @@
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+
+cmake_minimum_required(VERSION 2.6.3)
+project(FortranCInterface C Fortran)
+include(${FortranCInterface_BINARY_DIR}/Input.cmake OPTIONAL)
+
+# Check if the C compiler supports '$' in identifiers.
+include(CheckCSourceCompiles)
+check_c_source_compiles("
+extern int dollar$(void);
+int main() { return 0; }
+" C_SUPPORTS_DOLLAR)
+
+# List manglings of global symbol names to try.
+set(global_symbols
+  my_sub    # VisualAge
+  my_sub_   # GNU, Intel, HP, SunPro, MIPSpro
+  my_sub__  # GNU g77
+  MY_SUB    # Intel on Windows
+  mysub     # VisualAge
+  mysub_    # GNU, Intel, HP, SunPro, MIPSpro
+  MYSUB     # Intel on Windows
+  ${FortranCInterface_GLOBAL_SYMBOLS}
+  )
+list(REMOVE_DUPLICATES global_symbols)
+
+# List manglings of module symbol names to try.
+set(module_symbols
+  __my_module_MOD_my_sub  # GNU 4.3
+  __my_module_NMOD_my_sub # VisualAge
+  __my_module__my_sub     # GNU 4.2
+  __mymodule_MOD_mysub    # GNU 4.3
+  __mymodule_NMOD_mysub   # VisualAge
+  __mymodule__mysub       # GNU 4.2
+  my_module$my_sub        # HP
+  my_module_mp_my_sub_    # Intel
+  MY_MODULE_mp_MY_SUB     # Intel on Windows
+  my_module_my_sub_       # PGI
+  mymodule$mysub          # HP
+  mymodule_mp_mysub_      # Intel
+  MYMODULE_mp_MYSUB       # Intel on Windows
+  mymodule_mysub_         # PGI
+  ${FortranCInterface_MODULE_SYMBOLS}
+  )
+list(REMOVE_DUPLICATES module_symbols)
+
+# Note that some compiler manglings cannot be invoked from C:
+#   MIPSpro uses "MY_SUB.in.MY_MODULE"
+#   SunPro uses "my_module.my_sub_"
+#   PathScale uses "MY_SUB.in.MY_MODULE"
+
+# Add module symbols only with Fortran90.
+if(CMAKE_Fortran_COMPILER_SUPPORTS_F90)
+  set(myfort_modules mymodule.f90 my_module.f90)
+  set(call_mod call_mod.f90)
+  set_property(SOURCE main.F PROPERTY COMPILE_DEFINITIONS CALL_MOD)
+else()
+  set(module_symbols)
+endif()
+
+# Generate C symbol sources.
+foreach(symbol IN LISTS global_symbols module_symbols)
+  # Skip symbols with '$' if C cannot handle them.
+  if(C_SUPPORTS_DOLLAR OR NOT "${symbol}" MATCHES "\\$")
+    if("${symbol}" MATCHES "SUB")
+      set(upper "-UPPER")
+    else()
+      set(upper)
+    endif()
+    string(REPLACE "$" "S" name "${symbol}")
+    set(source ${CMAKE_CURRENT_BINARY_DIR}/symbols/${name}${upper}.c)
+    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/symbol.c.in ${source} @ONLY)
+    list(APPEND symbol_sources ${source})
+  endif()
+endforeach()
+
+# Provide symbols through Fortran.
+add_library(myfort STATIC mysub.f my_sub.f ${myfort_modules})
+
+# Provide symbols through C but fall back to Fortran.
+add_library(symbols STATIC mymodule_.c my_module_.c ${symbol_sources})
+target_link_libraries(symbols myfort)
+
+# Require symbols through Fortran.
+add_executable(FortranCInterface main.F call_sub.f ${call_mod})
+target_link_libraries(FortranCInterface symbols)
Index: cmake/CheckHeaderSTDC.cmake
===================================================================
--- cmake/CheckHeaderSTDC.cmake	(revision 0)
+++ cmake/CheckHeaderSTDC.cmake	(revision 0)
@@ -0,0 +1,65 @@
+#
+# - Check if the system has the ANSI C files
+# CHECK_HEADER_STDC
+#
+# The following variables may be set before calling this macro to
+# modify the way the check is run:
+#
+#  CMAKE_REQUIRED_FLAGS = string of compile command line flags
+#  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
+#  CMAKE_REQUIRED_INCLUDES = list of include directories
+# Copyright (c) 2009, Michihiro NAKAJIMA
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+MACRO (CHECK_HEADER_STDC)
+  IF(NOT DEFINED STDC_HEADERS)
+    IF(CMAKE_REQUIRED_INCLUDES)
+      SET(CHECK_HEADER_STDC_C_INCLUDE_DIRS "-DINCLUDE_DIRECTORIES=${CMAKE_REQUIRED_INCLUDES}")
+    ELSE(CMAKE_REQUIRED_INCLUDES)
+      SET(CHECK_HEADER_STDC_C_INCLUDE_DIRS)
+    ENDIF(CMAKE_REQUIRED_INCLUDES)
+    SET(MACRO_CHECK_HEADER_STDC_FLAGS ${CMAKE_REQUIRED_FLAGS})
+
+    MESSAGE(STATUS "Cheking for ANSI C header files")
+    TRY_RUN(CHECK_HEADER_STDC_result
+      CHECK_HEADER_STDC_compile_result
+      ${CMAKE_BINARY_DIR}
+      ${CMAKE_CURRENT_SOURCE_DIR}/cmake/CheckHeaderSTDC.c
+      COMPILE_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}
+      CMAKE_FLAGS
+      -DCOMPILE_DEFINITIONS:STRING=${MACRO_CHECK_HEADER_STDC_FLAGS}
+      "${CHECK_HEADER_STDC_C_INCLUDE_DIRS}"
+      OUTPUT_VARIABLE OUTPUT)
+
+    IF(CHECK_HEADER_STDC_compile_result AND CHECK_HEADER_STDC_result EQUAL 0)
+      FIND_PATH(CHECK_HEADER_STDC_path "string.h")
+      IF (CHECK_HEADER_STDC_path)
+        FILE(STRINGS "${CHECK_HEADER_STDC_path}/string.h" CHECK_HEADER_STDC_result REGEX "[^a-zA-Z_]memchr[^a-zA-Z_]")
+	IF (CHECK_HEADER_STDC_result)
+          FILE(STRINGS "${CHECK_HEADER_STDC_path}/stdlib.h" CHECK_HEADER_STDC_result REGEX "[^a-zA-Z_]free[^a-zA-Z_]")
+	ENDIF (CHECK_HEADER_STDC_result)
+      ENDIF (CHECK_HEADER_STDC_path)
+    ENDIF(CHECK_HEADER_STDC_compile_result AND CHECK_HEADER_STDC_result EQUAL 0)
+
+    IF(CHECK_HEADER_STDC_result)
+      MESSAGE(STATUS "Cheking for ANSI C header files - found")
+      SET(STDC_HEADERS 1 CACHE INTERNAL "Have ANSI C headers")
+      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
+        "Determining if the include file ${INCLUDE} "
+        "exists passed with the following output:\n"
+        "${OUTPUT}\n\n")
+    ELSE(CHECK_HEADER_STDC_result)
+      MESSAGE(STATUS "Cheking for ANSI C header files - not found")
+      SET(STDC_HEADERS "" CACHE INTERNAL "Have ANSI C headers")
+      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log
+        "Determining if the include file ${INCLUDE} "
+        "exists failed with the following output:\n"
+        "${OUTPUT}\n\n")
+    ENDIF(CHECK_HEADER_STDC_result)
+
+  ENDIF(NOT DEFINED STDC_HEADERS)
+ENDMACRO (CHECK_HEADER_STDC)
+
Index: cmake/Packaging.cmake
===================================================================
--- cmake/Packaging.cmake	(revision 0)
+++ cmake/Packaging.cmake	(revision 0)
@@ -0,0 +1,115 @@
+#-----------------------------------------------
+# packaging
+#-----------------------------------------------
+
+OPTION(ENABLE_PACKAGING "Enable Packaging" ON)
+
+IF(CMAKE_C_COMPILER MATCHES gcc)
+    EXEC_PROGRAM(${CMAKE_C_COMPILER}
+        ARGS -dumpversion
+        OUTPUT_VARIABLE PACKAGE_COMPILER)
+    SET(PACKAGE_COMPILER gcc-${PACKAGE_COMPILER})
+ELSE()
+    SET(PACKAGE_COMPILER ${CMAKE_CXX_COMPILER})
+ENDIF()
+
+IF (UNIX AND NOT APPLE) # LINUX
+    OPTION(BUILD_RPM "Enable RPM Packaging" OFF)
+ENDIF()
+
+IF(ENABLE_PACKAGING OR BUILD_RPM)
+
+    INCLUDE(InstallRequiredSystemLibraries)
+
+    CONFIGURE_FILE(${MATIO_SOURCE_DIR}/README  README.txt  COPYONLY)
+    CONFIGURE_FILE(${MATIO_SOURCE_DIR}/COPYING COPYING.txt COPYONLY)
+
+    SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "matio library for matlab IOs")
+    SET(CPACK_PACKAGE_VENDOR "Christopher Hulbert")
+    SET(CPACK_PACKAGE_DESCRIPTION_FILE "${MATIO_BINARY_DIR}/README.txt")
+    SET(CPACK_RESOURCE_FILE_LICENSE "${MATIO_BINARY_DIR}/COPYING.txt")
+    SET(CPACK_PACKAGE_INSTALL_DIRECTORY "matio")
+    SET(CPACK_PACKAGE_CONTACT "cch@isl-inc.com")
+
+    IF(${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
+        SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE amd64)
+        SET(CPACK_RPM_PACKAGE_ARCHITECTURE x86_64)
+    ELSE()
+        SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE i386)
+        SET(CPACK_RPM_PACKAGE_ARCHITECTURE i386)
+    ENDIF()
+
+    SET(PACKAGE_NAME "matio-${PACKAGE_VERSION_MAJOR}.${PACKAGE_VERSION_MINOR}.${PACKAGE_VERSION_PATCH}")
+    IF(UNIX)
+        IF (APPLE)
+            SET(PACKAGE_NAME ${PACKAGE_NAME}-MacOSX-Intel)
+            IF(BUILD_UNIVERSAL)
+                SET(PACKAGE_NAME ${PACKAGE_NAME}-Universal)
+            ENDIF()
+        ELSE()
+            SET(PACKAGE_NAME ${PACKAGE_NAME}-Linux.${CPACK_RPM_PACKAGE_ARCHITECTURE})
+        ENDIF()
+    ELSE()
+        SET(PACKAGE_NAME ${PACKAGE_NAME}-win32-x86)
+    ENDIF()
+
+    SET(PACKAGE_NAME ${PACKAGE_NAME}-${PACKAGE_COMPILER})
+
+    IF (USE_OMP)
+        SET(PACKAGE_NAME ${PACKAGE_NAME}-OpenMP)
+    ENDIF()
+
+    IF(BUILD_SHARED)
+        IF(ENABLE_PYTHON)
+            SET(PACKAGE_NAME ${PACKAGE_NAME}-python)
+        ENDIF()
+        SET(PACKAGE_NAME ${PACKAGE_NAME}-shared)
+    ELSE()
+        SET(PACKAGE_NAME ${PACKAGE_NAME}-static)
+    ENDIF()
+
+    SET(CPACK_PACKAGE_FILE_NAME ${PACKAGE_NAME})
+
+    IF (WIN32)
+        # There is a bug in NSIS that does not handle full unix paths properly. Make
+        # sure there is at least one set of four (4) backlasshes.
+        SET(CPACK_NSIS_DISPLAY_NAME "matio library for matlab IOs")
+        SET(CPACK_NSIS_HELP_LINK "http:\\\\\\\\sourceforge.net/projects/matio/support")
+        SET(CPACK_NSIS_URL_INFO_ABOUT "https:\\\\\\\\gforge.inria.fr/projects/openmeeg/")
+        SET(CPACK_NSIS_CONTACT "cch@isl-inc.com")
+        SET(CPACK_NSIS_MODIFY_PATH ON)
+    ENDIF()
+
+    SET(CPACK_SOURCE_STRIP_FILES "")
+
+    IF(UNIX AND NOT APPLE)
+        SET(CPACK_GENERATOR "TGZ")
+    ENDIF()
+
+    IF(APPLE)
+        SET(CPACK_GENERATOR "PackageMaker;TGZ")
+    ENDIF()
+
+    INCLUDE(CPack)
+
+    IF(UNIX AND BUILD_RPM) # linux
+        SET(CPACK_GENERATOR "${CPACK_GENERATOR};RPM")
+        IF (CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION LESS 8)
+            INCLUDE(UseRPMTools)
+            IF (RPMTools_FOUND)
+                RPMTools_ADD_RPM_TARGETS(${PROJECT_NAME} "${PROJECT_SOURCE_DIR}/packaging/${PROJECT_NAME}.spec.in")
+            ENDIF()
+        ELSE()
+            SET(CPACK_RPM_PACKAGE_LICENSE "LGPL")
+            SET(CPACK_RPM_PACKAGE_DESCRIPTION  "libmatio is an open-source library for reading/writing Matlab MAT files.  This
+library is designed for use by programs/libraries that do not have access or
+do not want to rely on Matlab's libmat shared library.")
+            SET(CPACK_RPM_PACKAGE_GROUP "Libraries")
+        ENDIF()
+    ENDIF()
+
+ENDIF()
+
+#IF (ENABLE_PACKAGING AND WIN32)
+#    INCLUDE(UseWin32dlls)
+#ENDIF()
Index: cmake/FindLibrary.cmake
===================================================================
--- cmake/FindLibrary.cmake	(revision 0)
+++ cmake/FindLibrary.cmake	(revision 0)
@@ -0,0 +1,24 @@
+OPTION(BUILD_SHARED "Build shared libs" ON)
+MARK_AS_ADVANCED(BUILD_SHARED)
+
+IF (BUILD_SHARED)
+    SET(LIB_TYPE SHARED)
+ELSE()
+    SET(LIB_TYPE STATIC)
+ENDIF()
+
+STRING(COMPARE NOTEQUAL "${BUILD_SHARED_STATUS}" "" BUILD_SHARED_STATUS_NOT_EMPTY)
+IF(BUILD_SHARED_STATUS_NOT_EMPTY)
+    STRING(COMPARE NOTEQUAL "${BUILD_SHARED_STATUS}" "${BUILD_SHARED}" RESET)
+ENDIF()
+
+# Store in cache previous value of BUILD_SHARED
+SET(BUILD_SHARED_STATUS "${BUILD_SHARED}" CACHE INTERNAL "Previous shared status" FORCE)
+
+FUNCTION(FIND_LIBRARY VAR)
+    IF(${RESET})
+        SET(${VAR} NOTFOUND CACHE STRING "Atlas Lib" FORCE)
+    ENDIF()
+    _FIND_LIBRARY(${VAR} ${ARGN})
+    MARK_AS_ADVANCED(${VAR})
+ENDFUNCTION()
Index: cmake/CheckHeaderSTDC.c
===================================================================
--- cmake/CheckHeaderSTDC.c	(revision 0)
+++ cmake/CheckHeaderSTDC.c	(revision 0)
@@ -0,0 +1,20 @@
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+
+#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+
+int
+main()
+{
+  int i;
+
+  for (i = 0; i < 256; i++) {
+    if (XOR(islower(i), ISLOWER(i)) || toupper(i) != TOUPPER(i))
+      return 2;
+  }
+  return 0;
+}
Index: cmake/FortranCInterface.cmake.old
===================================================================
--- cmake/FortranCInterface.cmake.old	(revision 0)
+++ cmake/FortranCInterface.cmake.old	(revision 0)
@@ -0,0 +1,329 @@
+# FortranCInterface.cmake
+#
+# This file defines the function create_fortran_c_interface.
+# this function is used to create a configured header file 
+# that contains a mapping from C to a Fortran function using
+# the correct name mangling scheme as defined by the current 
+# fortran compiler.  
+#
+# The function tags a list of functions and the name of 
+# a header file to configure.  
+#
+# This file also defines some helper functions that are used
+# to detect the fortran name mangling scheme used by the 
+# current Fortran compiler.
+#  test_fortran_mangling - test a single fortran mangling 
+#  discover_fortran_mangling - loop over all combos of fortran
+#   name mangling and call test_fortran_mangling until one of them
+#   works.
+#  discover_fortran_module_mangling - try different types of 
+#  fortran modle name mangling to find one that works
+#
+#
+#
+# this function tests a single fortran mangling.  
+# CODE - test code to try should define a subroutine called "sub"
+# PREFIX - string to put in front of sub
+# POSTFIX - string to put after sub
+# ISUPPER - if TRUE then sub will be called as SUB
+# DOC - string used in status checking Fortran ${DOC} linkage
+# SUB - the name of the SUB to call
+# RESULT place to store result TRUE if this linkage works, FALSE
+#        if not.
+#
+function(test_fortran_mangling CODE PREFIX ISUPPER POSTFIX DOC SUB RESULT)
+  if(ISUPPER)
+    string(TOUPPER "${SUB}" sub)
+  else(ISUPPER) 
+    string(TOLOWER "${SUB}" sub)
+  endif(ISUPPER)
+  set(FUNCTION "${PREFIX}${sub}${POSTFIX}")
+  # create a fortran file with sub called sub
+  # 
+  set(TMP_DIR
+    "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/CheckFortranLink")
+  file(REMOVE_RECURSE "${TMP_DIR}")
+  file(WRITE "${TMP_DIR}/test.f" "${CODE}"    )
+  message(STATUS "checking Fortran ${DOC} linkage: ${FUNCTION}")
+  file(WRITE "${TMP_DIR}/ctof.c"
+    "
+      extern ${FUNCTION}();
+      int main() { ${FUNCTION}(); return 0;}
+    "
+    )
+  file(WRITE "${TMP_DIR}/CMakeLists.txt"
+    "
+     project(testf C Fortran)
+     add_library(flib test.f)
+     add_executable(ctof ctof.c)
+     target_link_libraries(ctof flib)
+    "
+    )
+  set(FORTRAN_NAME_MANGLE_TEST FALSE)
+  try_compile(FORTRAN_NAME_MANGLE_TEST "${TMP_DIR}" "${TMP_DIR}"
+    testf
+    OUTPUT_VARIABLE output)
+  if(FORTRAN_NAME_MANGLE_TEST)
+    set(${RESULT} TRUE PARENT_SCOPE)
+  else()
+    set(${RESULT} FALSE PARENT_SCOPE)
+  endif()
+endfunction(test_fortran_mangling)
+
+function(test_fortran_mangling_from_library LIBNAME PREFIX ISUPPER POSTFIX DOC SUB RESULT)
+  if(ISUPPER)
+    string(TOUPPER "${SUB}" sub)
+  else(ISUPPER) 
+    string(TOLOWER "${SUB}" sub)
+  endif(ISUPPER)
+  set(FUNCTION "${PREFIX}${sub}${POSTFIX}")
+  message(STATUS "checking Fortran ${DOC} linkage: ${FUNCTION}")
+  INCLUDE (CheckLibraryExists)
+  CHECK_LIBRARY_EXISTS(${LIBNAME} ${FUNCTION} "/usr/lib64" FORTRAN_NAME_MANGLE_TEST)
+  set(${RESULT} ${FORTRAN_NAME_MANGLE_TEST} PARENT_SCOPE)
+endfunction()
+
+# this function discovers the name mangling scheme used
+# for functions in a fortran module.  
+function(discover_fortran_module_mangling prefix suffix found)
+  set(CODE 
+    "
+      module test_interface
+      interface dummy
+         module procedure sub
+      end interface
+      contains
+        subroutine sub
+        end subroutine
+      end module test_interface
+    ")
+  set(worked FALSE)
+  foreach(interface 
+      "test_interface$" 
+      "TEST_INTERFACE_mp_" 
+      "_test_interface__" 
+      "__test_interface__" 
+      "__test_interface_NMOD_" 
+      "__test_interface_MOD_")
+    test_fortran_mangling("${CODE}" "${interface}"
+      ${FORTRAN_C_MANGLING_UPPERCASE} "" "module" "sub" worked)
+    if(worked)
+      # if this is the upper case module match then
+      # lower case it for the extraction of pre and post strings
+      if("${interface}" MATCHES "TEST_INTERFACE")
+        string(TOLOWER "${interface}" interface)
+      endif()
+      string(REGEX REPLACE "(.*)test_interface(.*)" "\\1" pre "${interface}")
+      string(REGEX REPLACE "(.*)test_interface(.*)" "\\2" post "${interface}")
+      set(${prefix} "${pre}" PARENT_SCOPE)
+      set(${suffix} "${post}" PARENT_SCOPE)
+      set(${found} TRUE PARENT_SCOPE)
+      return()
+    endif(worked)
+  endforeach(interface)
+  if(NOT worked)
+    message(STATUS "Failed to find C binding to Fortran module functions.")
+    set(${prefix} "BROKEN_C_FORTRAN_MODULE_BINDING" PARENT_SCOPE)
+    set(${suffix} "BROKEN_C_FORTRAN_MODULE_BINDING" PARENT_SCOPE)
+    set(${found} FALSE PARENT_SCOPE)
+  endif(NOT worked)
+endfunction(discover_fortran_module_mangling)
+
+
+function(discover_fortran_mangling prefix isupper suffix extra_under_score
+    found )
+  set(CODE 
+    "
+      subroutine sub
+      end subroutine sub
+    ")
+  foreach(post "_" "")
+    foreach(isup FALSE TRUE)
+      foreach(pre "" "_" "__")
+        set(worked FALSE)
+        test_fortran_mangling("${CODE}" "${pre}" ${isup}
+          "${post}" "function" sub worked )
+        if(worked)
+          message(STATUS "found Fortran function linkage")
+          set(${isupper} "${isup}" PARENT_SCOPE)
+          set(${prefix} "${pre}" PARENT_SCOPE)
+          set(${suffix} "${post}" PARENT_SCOPE)
+          set(${found} TRUE PARENT_SCOPE)
+          set(CODE 
+            "
+      subroutine my_sub
+      end subroutine my_sub
+    ")
+          set(worked FALSE)
+          test_fortran_mangling("${CODE}" "${pre}" ${isup}
+            "${post}" "function with _ " my_sub worked )
+          if(worked)
+            set(${extra_under_score} FALSE PARENT_SCOPE)
+          else(worked)
+            test_fortran_mangling("${CODE}" "${pre}" ${isup}
+              "${post}_" "function with _ " my_sub worked )
+            if(worked)
+              set(${extra_under_score} TRUE PARENT_SCOPE)
+            endif(worked)
+          endif(worked)
+        return()
+        endif()
+      endforeach()
+    endforeach()
+  endforeach()
+  set(${found} FALSE PARENT_SCOPE)
+endfunction(discover_fortran_mangling)
+
+function(discover_fortran_mangling_from_library libname function prefix isupper suffix extra_under_score
+    found )
+  Find_Library(library ${libname})
+  foreach(post "_" "")
+    foreach(isup FALSE TRUE)
+      foreach(pre "" "_" "__")
+        set(worked FALSE)
+        message("${libname}" "${library}" "${pre}" "${isup}" "${post}" "function" "${function}" worked )
+        test_fortran_mangling_from_library("${libname}" "${pre}" "${isup}" "${post}" "function" "${function}" worked )
+        if(worked)
+          message(STATUS "found Fortran function linkage")
+          set(${isupper} "${isup}" PARENT_SCOPE)
+          set(${prefix} "${pre}" PARENT_SCOPE)
+          set(${suffix} "${post}" PARENT_SCOPE)
+          set(${found} TRUE PARENT_SCOPE)
+          set(${extra_under_score} FALSE PARENT_SCOPE)
+          return()
+        endif()
+      endforeach()
+    endforeach()
+  endforeach()
+  set(${found} FALSE PARENT_SCOPE)
+endfunction()
+
+function(is_fortran_available result)
+  get_property(_LANGUAGES_ GLOBAL PROPERTY ENABLED_LANGUAGES)
+  if(_LANGUAGES_ MATCHES Fortran)
+    SET(result 1)
+  endif()
+    SET(result 0)
+  return()
+endfunction()
+
+# Parse arguments to create_fortran_c_interface and sets the variables
+# with the corresponding parameters. variable names are those of named args
+# or options prefixed with the given prefix. Arg names and options are
+given by the two lists arg_names and option_names.
+
+function(PARSE_PARAMETERS prefix arg_names option_names)
+  SET(DEFAULT_ARGS)
+  FOREACH(name ${arg_names} ${option_names})
+    SET(${prefix}_${name})
+  ENDFOREACH(arg_name)
+
+  SET(current_arg_name DEFAULT_ARGS)
+  SET(current_arg_list)
+  FOREACH(arg ${ARGN})
+    LIST(FIND ${arg_names} ${arg} is_arg_name)
+    IF (is_arg_name NOT EQUAL -1)
+      SET(${prefix}_${current_arg_name} ${current_arg_list})
+      SET(current_arg_name ${arg})
+      SET(current_arg_list)
+    ELSE ()
+      LIST(FIND ${option_names} ${arg} is_option)
+      IF (is_option)
+        SET(${prefix}_${arg} TRUE)
+      ELSE ()
+        SET(current_arg_list ${current_arg_list} ${arg})
+      ENDIF ()
+    ENDIF ()
+  ENDFOREACH()
+  SET(${prefix}_${current_arg_name} ${current_arg_list})`
+endfunction()
+
+function(discover_fortran_c_interface use_library)
+  # find regular fortran function mangling
+  if ( ${use_library} )
+    LIST(GET ${ARGN} 1 flibrary)
+    LIST(REMOVE_AT ${ARGN} 1)
+    discover_fortran_mangling_from_library(${flibrary} dcopy prefix isupper suffix extra_under found)
+  else()
+    discover_fortran_mangling(prefix isupper suffix extra_under found)
+  endif()
+  if(NOT found)
+    message(SEND_ERROR "Could not find fortran c name mangling (probably no fortran compiler available).")
+    return()
+  endif(NOT found)
+  # find fortran module function mangling
+  set(FORTRAN_C_PREFIX "${prefix}" CACHE INTERNAL
+    "PREFIX for Fortran to c name mangling")
+  set(FORTRAN_C_SUFFIX "${suffix}" CACHE INTERNAL
+    "SUFFIX for Fortran to c name mangling")
+  set(FORTRAN_C_MANGLING_UPPERCASE ${isupper} CACHE INTERNAL 
+    "Was fortran to c mangling found" )
+  set(FORTRAN_C_MANGLING_EXTRA_UNDERSCORE ${extra_under} CACHE INTERNAL 
+    "If a function has a _ in the name does the compiler append an extra _" )
+  set(FORTRAN_C_MANGLING_FOUND TRUE CACHE INTERNAL 
+    "Was fortran to c mangling found" )
+  set(prefix )
+  set(suffix )
+  set(found FALSE)
+  # only try this if the compiler is F90 compatible
+  if(CMAKE_Fortran_COMPILER_SUPPORTS_F90)
+    discover_fortran_module_mangling(prefix suffix found)
+  endif(CMAKE_Fortran_COMPILER_SUPPORTS_F90)
+  if(found)
+    message(STATUS "found Fortran module linkage")
+  else(found)
+    message(STATUS "Failed to find Fortran module linkage")
+  endif(found)
+  set(FORTRAN_C_MODULE_PREFIX "${prefix}" CACHE INTERNAL
+    "PREFIX for Fortran to c name mangling")
+  set(FORTRAN_C_MODULE_SUFFIX "${suffix}" CACHE INTERNAL
+    "SUFFIX for Fortran to c name mangling")
+  set(FORTRAN_C_MODULE_MANGLING_FOUND ${found} CACHE INTERNAL
+    "Was for Fortran to c name mangling found for modules")
+endfunction()
+
+function(create_fortran_c_interface NAMESPACE FUNCTIONS HEADER)
+  PARSE_PARAMETERS("FORTRAN_C_" "USE_LIBRARY" "GENERIC;APPEND" ${ARGN})
+  if(NOT FORTRAN_C_MANGLING_FOUND)
+    discover_fortran_c_interface()
+  endif()
+  foreach(f ${${FUNCTIONS}})
+    if(FORTRAN_C_MANGLING_UPPERCASE)
+      string(TOUPPER "${f}" fcase)
+    else()
+      string(TOLOWER "${f}" fcase)
+    endif()
+    if("${f}" MATCHES ":")
+      string(REGEX REPLACE "(.*):(.*)" "\\1" module "${f}")
+      string(REGEX REPLACE "(.*):(.*)" "\\2" function "${f}")
+      string(REGEX REPLACE "(.*):(.*)" "\\1" module_case "${fcase}")
+      string(REGEX REPLACE "(.*):(.*)" "\\2" function_case "${fcase}")
+      set(HEADER_CONTENT "${HEADER_CONTENT}
+#define ${NAMESPACE}${module}_${function} ${FORTRAN_C_MODULE_PREFIX}${module_case}${FORTRAN_C_MODULE_SUFFIX}${function_case}
+")
+    else("${f}" MATCHES ":")
+      set(function "${FORTRAN_C_PREFIX}${fcase}${FORTRAN_C_SUFFIX}")
+      if("${f}" MATCHES "_" AND FORTRAN_C_MANGLING_EXTRA_UNDERSCORE)
+        set(function "${function}_")
+      endif("${f}" MATCHES "_" AND FORTRAN_C_MANGLING_EXTRA_UNDERSCORE)
+      set(HEADER_CONTENT "${HEADER_CONTENT}
+#define ${NAMESPACE}${f} ${function}
+")
+    endif("${f}" MATCHES ":")
+  endforeach(f)
+  set(fcase "x")
+  if(FORTRAN_C_MANGLING_UPPERCASE)
+    set(fcase "X")
+  endif()
+  if ( NOT ${FORTRAN_C_PREFIX} EQUAL "")
+    set(fcase " ## ${fcase}")
+  endif()
+  if ( NOT ${FORTRAN_C_SUFFIX} EQUAL "")
+    set(fcase "${fcase} ## ")
+  endif()
+  set(HEADER_CONTENT "#define Fortran_Function(x,X) ${FORTRAN_C_PREFIX}${fcase}${FORTRAN_C_SUFFIX}")
+  configure_file(
+    "${CMAKE_ROOT}/Modules/FortranCInterface.h.in"
+    ${HEADER} @ONLY)
+  message(STATUS "created ${HEADER}")
+endfunction()
Index: cmake/CMakeFortranCompiler.cmake.in
===================================================================
--- cmake/CMakeFortranCompiler.cmake.in	(revision 0)
+++ cmake/CMakeFortranCompiler.cmake.in	(revision 0)
@@ -0,0 +1,29 @@
+SET(CMAKE_Fortran_COMPILER "@CMAKE_Fortran_COMPILER@")
+SET(CMAKE_Fortran_COMPILER_ARG1 "@CMAKE_Fortran_COMPILER_ARG1@")
+SET(CMAKE_Fortran_COMPILER_ID "@CMAKE_Fortran_COMPILER_ID@")
+SET(CMAKE_Fortran_PLATFORM_ID "@CMAKE_Fortran_PLATFORM_ID@")
+SET(CMAKE_AR "@CMAKE_AR@")
+SET(CMAKE_RANLIB "@CMAKE_RANLIB@")
+SET(CMAKE_COMPILER_IS_GNUG77 @CMAKE_COMPILER_IS_GNUG77@)
+SET(CMAKE_Fortran_COMPILER_LOADED 1)
+SET(CMAKE_COMPILER_IS_MINGW @CMAKE_COMPILER_IS_MINGW@)
+SET(CMAKE_COMPILER_IS_CYGWIN @CMAKE_COMPILER_IS_CYGWIN@)
+IF(CMAKE_COMPILER_IS_CYGWIN)
+  SET(CYGWIN 1)
+  SET(UNIX 1)
+ENDIF(CMAKE_COMPILER_IS_CYGWIN)
+
+SET(CMAKE_Fortran_COMPILER_ENV_VAR "FC")
+
+IF(CMAKE_COMPILER_IS_MINGW)
+  SET(MINGW 1)
+ENDIF(CMAKE_COMPILER_IS_MINGW)
+SET(CMAKE_Fortran_COMPILER_ID_RUN 1)
+SET(CMAKE_Fortran_SOURCE_FILE_EXTENSIONS f;F;f77;F77;f90;F90;for;For;FOR;f95;F95)
+SET(CMAKE_Fortran_IGNORE_EXTENSIONS h;H;o;O;obj;OBJ;def;DEF;rc;RC)
+SET(CMAKE_Fortran_LINKER_PREFERENCE 20)
+IF(UNIX)
+  SET(CMAKE_Fortran_OUTPUT_EXTENSION .o)
+ELSE(UNIX)
+  SET(CMAKE_Fortran_OUTPUT_EXTENSION .obj)
+ENDIF(UNIX)
Index: cmake/UseWin32dlls.cmake
===================================================================
--- cmake/UseWin32dlls.cmake	(revision 0)
+++ cmake/UseWin32dlls.cmake	(revision 0)
@@ -0,0 +1,21 @@
+IF (WIN32 AND ENABLE_PACKAGING)
+
+     # TODO.
+
+#    SET(WIN32_MANIFEST "${CMAKE_SOURCE_DIR}/../win32addons/Microsoft.VC80.CRT.manifest")
+#    SET(MSVCP80 "${OpenMEEG_SOURCE_DIR}/../win32addons/msvcp80.dll")
+#    SET(MSVCR80 "${OpenMEEG_SOURCE_DIR}/../win32addons/msvcr80.dll")
+
+    ADD_CUSTOM_TARGET(copy_dlls ALL
+        COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/win32depends/
+        COMMAND ${CMAKE_COMMAND} -E copy ${MSVCP80} ${CMAKE_BINARY_DIR}/win32depends/
+        COMMAND ${CMAKE_COMMAND} -E copy ${MSVCR80} ${CMAKE_BINARY_DIR}/win32depends/
+        COMMAND ${CMAKE_COMMAND} -E copy ${WIN32_MANIFEST} ${CMAKE_BINARY_DIR}/win32depends/
+    )
+
+    INSTALL(DIRECTORY ${MATIO_BINARY_DIR}/win32depends/ DESTINATION bin
+              PATTERN "${MATIO_BINARY_DIR}/win32depends/*"
+              PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
+                          GROUP_EXECUTE GROUP_READ)
+
+ENDIF()
Index: cmake/Boolean.cmake
===================================================================
--- cmake/Boolean.cmake	(revision 0)
+++ cmake/Boolean.cmake	(revision 0)
@@ -0,0 +1,7 @@
+MACRO(BOOLEAN name)
+    IF (${ARGN})
+        SET(${name} 1)
+    ELSE()
+        UNSET(${name})
+    ENDIF()
+ENDMACRO()
Index: cmake/FortranCInterface.cmake
===================================================================
--- cmake/FortranCInterface.cmake	(revision 0)
+++ cmake/FortranCInterface.cmake	(revision 0)
@@ -0,0 +1,309 @@
+# - Fortran/C Interface Detection
+# This module automatically detects the API by which C and Fortran
+# languages interact.  Variables indicate if the mangling is found:
+#   FortranCInterface_GLOBAL_FOUND = Global subroutines and functions
+#   FortranCInterface_MODULE_FOUND = Module subroutines and functions
+#                                    (declared by "MODULE PROCEDURE")
+# A function is provided to generate a C header file containing macros
+# to mangle symbol names:
+#   FortranCInterface_HEADER(<file>
+#                            [MACRO_NAMESPACE <macro-ns>]
+#                            [SYMBOL_NAMESPACE <ns>]
+#                            [SYMBOLS [<module>:]<function> ...])
+# It generates in <file> definitions of the following macros:
+#   #define FortranCInterface_GLOBAL (name,NAME) ...
+#   #define FortranCInterface_GLOBAL_(name,NAME) ...
+#   #define FortranCInterface_MODULE (mod,name, MOD,NAME) ...
+#   #define FortranCInterface_MODULE_(mod,name, MOD,NAME) ...
+# These macros mangle four categories of Fortran symbols,
+# respectively:
+#   - Global symbols without '_': call mysub()
+#   - Global symbols with '_'   : call my_sub()
+#   - Module symbols without '_': use mymod; call mysub()
+#   - Module symbols with '_'   : use mymod; call my_sub()
+# If mangling for a category is not known, its macro is left undefined.
+# All macros require raw names in both lower case and upper case.
+# The MACRO_NAMESPACE option replaces the default "FortranCInterface_"
+# prefix with a given namespace "<macro-ns>".
+#
+# The SYMBOLS option lists symbols to mangle automatically with C
+# preprocessor definitions:
+#   <function>          ==> #define <ns><function> ...
+#   <module>:<function> ==> #define <ns><module>_<function> ...
+# If the mangling for some symbol is not known then no preprocessor
+# definition is created, and a warning is displayed.
+# The SYMBOL_NAMESPACE option prefixes all preprocessor definitions
+# generated by the SYMBOLS option with a given namespace "<ns>".
+#
+# Example usage:
+#   include(FortranCInterface)
+#   FortranCInterface_HEADER(FC.h MACRO_NAMESPACE "FC_")
+# This creates a "FC.h" header that defines mangling macros
+# FC_GLOBAL(), FC_GLOBAL_(), FC_MODULE(), and FC_MODULE_().
+#
+# Example usage:
+#   include(FortranCInterface)
+#   FortranCInterface_HEADER(FCMangle.h
+#                            MACRO_NAMESPACE "FC_"
+#                            SYMBOL_NAMESPACE "FC_"
+#                            SYMBOLS mysub mymod:my_sub)
+# This creates a "FCMangle.h" header that defines the same FC_*() mangling
+# macros as the previous example plus preprocessor symbols FC_mysub
+# and FC_mymod_my_sub.
+#
+# Another function is provided to verify that the Fortran and C/C++
+# compilers work together:
+#   FortranCInterface_VERIFY([CXX] [QUIET])
+# It tests whether a simple test executable using Fortran and C (and
+# C++ when the CXX option is given) compiles and links successfully.
+# The result is stored in the cache entry FortranCInterface_VERIFIED_C
+# (or FortranCInterface_VERIFIED_CXX if CXX is given) as a boolean.
+# If the check fails and QUIET is not given the function terminates
+# with a FATAL_ERROR message describing the problem.  The purpose of
+# this check is to stop a build early for incompatible compiler
+# combinations.
+#
+# FortranCInterface is aware of possible GLOBAL and MODULE manglings
+# for many Fortran compilers, but it also provides an interface to
+# specify new possible manglings.  Set the variables
+#   FortranCInterface_GLOBAL_SYMBOLS
+#   FortranCInterface_MODULE_SYMBOLS
+# before including FortranCInterface to specify manglings of the
+# symbols "MySub", "My_Sub", "MyModule:MySub", and "My_Module:My_Sub".
+# For example, the code:
+#   set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub__ MYSUB_)
+#     #                                  ^^^^^  ^^^^^^   ^^^^^
+#   set(FortranCInterface_MODULE_SYMBOLS
+#       __mymodule_MOD_mysub __my_module_MOD_my_sub)
+#     #   ^^^^^^^^     ^^^^^   ^^^^^^^^^     ^^^^^^
+#   include(FortranCInterface)
+# tells FortranCInterface to try given GLOBAL and MODULE manglings.
+# (The carets point at raw symbol names for clarity in this example
+# but are not needed.)
+
+#=============================================================================
+# Copyright 2008-2009 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distributed this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+#-----------------------------------------------------------------------------
+# Execute at most once in a project.
+if(FortranCInterface_INCLUDED)
+  return()
+endif()
+
+set(FortranCInterface_INCLUDED TRUE)
+
+# Use CMake 2.6.0 behavior for this module regardless of including context.
+cmake_policy(PUSH)
+cmake_policy(VERSION 2.6.0)
+
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+function(FortranCInterface_HEADER file)
+  # Parse arguments.
+  if(IS_ABSOLUTE "${file}")
+    set(FILE "${file}")
+  else()
+    set(FILE "${CMAKE_CURRENT_BINARY_DIR}/${file}")
+  endif()
+  set(MACRO_NAMESPACE "FortranCInterface_")
+  set(SYMBOL_NAMESPACE)
+  set(SYMBOLS)
+  set(doing)
+  foreach(arg ${ARGN})
+    if("x${arg}" MATCHES "^x(SYMBOLS|SYMBOL_NAMESPACE|MACRO_NAMESPACE|FROM_LIBRARY)$")
+      set(doing "${arg}")
+    elseif("x${doing}" MATCHES "^x(SYMBOLS|FROM_LIBRARY)$")
+      list(APPEND "${doing}" "${arg}")
+    elseif("x${doing}" MATCHES "^x(SYMBOL_NAMESPACE|MACRO_NAMESPACE)$")
+      set("${doing}" "${arg}")
+      set(doing)
+    else()
+      message(AUTHOR_WARNING "Unknown argument: \"${arg}\"")
+    endif()
+  endforeach()
+
+  #set(FortranCInterface_SOURCE_DIR ${CMAKE_ROOT}/Modules/FortranCInterface)
+  set(FortranCInterface_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/cmake/FortranCInterface)
+
+  # Create the interface detection project if it does not exist.
+  if(NOT FortranCInterface_BINARY_DIR)
+    set(FortranCInterface_BINARY_DIR ${CMAKE_BINARY_DIR}/CMakeFiles/FortranCInterface)
+    set(FortranCInterface_BINARY_DIR_Created true)
+  endif()
+
+  if (FROM_LIBRARY)
+    foreach (spec ${FROM_LIBRARY})
+      string(REGEX REPLACE "(.*)\\[(.*)]" "\\1" libname ${spec})
+      string(REGEX REPLACE "(.*)\\[(.*)]" "\\2" funcs ${spec})
+      string(REGEX REPLACE "," ";" funcs ${funcs})
+      find_library(library ${libname})
+      include(DetectFromLibrary)
+      foreach (func ${funcs})
+        detect_fortran_function(${libname} ${library} ${func})
+      endforeach()
+      unset(library CACHE)
+    endforeach()
+    CreateCFortranOutput()
+  else()
+
+    # Verify that C and Fortran are available.
+    foreach(lang C Fortran)
+      if(NOT CMAKE_${lang}_COMPILER_LOADED)
+        message(FATAL_ERROR
+          "FortranCInterface requires the ${lang} language to be enabled.")
+      endif()
+    endforeach()
+
+    # Detection of fortran mangling.
+    if(FortranCInterface_BINARY_DIR_Created)
+      include(${FortranCInterface_SOURCE_DIR}/Detect.cmake)
+    endif()
+  endif()
+
+  # Load the detection results.
+  include(${FortranCInterface_BINARY_DIR}/Output.cmake)
+
+  # Generate macro definitions.
+  set(HEADER_CONTENT)
+  set(_desc_GLOBAL  "/* Mangling for Fortran global symbols without underscores. */")
+  set(_desc_GLOBAL_ "/* Mangling for Fortran global symbols with underscores. */")
+  set(_desc_MODULE  "/* Mangling for Fortran module symbols without underscores. */")
+  set(_desc_MODULE_ "/* Mangling for Fortran module symbols with underscores. */")
+  foreach(macro GLOBAL GLOBAL_ MODULE MODULE_)
+    if(FortranCInterface_${macro}_MACRO)
+      set(HEADER_CONTENT "${HEADER_CONTENT}
+${_desc_${macro}}
+#define ${MACRO_NAMESPACE}${macro}${FortranCInterface_${macro}_MACRO}
+")
+    endif()
+  endforeach()
+
+  # Generate symbol mangling definitions.
+  if(SYMBOLS)
+    set(HEADER_CONTENT "${HEADER_CONTENT}
+/*--------------------------------------------------------------------------*/
+/* Mangle some symbols automatically.                                       */
+")
+  endif()
+  foreach(f ${SYMBOLS})
+    if("${f}" MATCHES ":")
+      # Module symbol name.  Parse "<module>:<function>" syntax.
+      string(REPLACE ":" ";" pieces "${f}")
+      list(GET pieces 0 module)
+      list(GET pieces 1 function)
+      string(TOUPPER "${module}" m_upper)
+      string(TOLOWER "${module}" m_lower)
+      string(TOUPPER "${function}" f_upper)
+      string(TOLOWER "${function}" f_lower)
+      if("${function}" MATCHES "_")
+        set(form "_")
+      else()
+        set(form "")
+      endif()
+      if(FortranCInterface_MODULE${form}_MACRO)
+        set(HEADER_CONTENT "${HEADER_CONTENT}#define ${SYMBOL_NAMESPACE}${module}_${function} ${MACRO_NAMESPACE}MODULE${form}(${m_lower},${f_lower}, ${m_upper},${f_upper})\n")
+      else()
+        message(AUTHOR_WARNING "No FortranCInterface mangling known for ${f}")
+      endif()
+    else()
+      # Global symbol name.
+      if("${f}" MATCHES "_")
+        set(form "_")
+      else()
+        set(form "")
+      endif()
+      string(TOUPPER "${f}" f_upper)
+      string(TOLOWER "${f}" f_lower)
+      if(FortranCInterface_GLOBAL${form}_MACRO)
+        set(HEADER_CONTENT "${HEADER_CONTENT}#define ${SYMBOL_NAMESPACE}${f} ${MACRO_NAMESPACE}GLOBAL${form}(${f_lower}, ${f_upper})\n")
+      else()
+        message(AUTHOR_WARNING "No FortranCInterface mangling known for ${f}")
+      endif()
+    endif()
+  endforeach(f)
+
+  # Store the content.
+  configure_file(${FortranCInterface_SOURCE_DIR}/Macro.h.in ${FILE} @ONLY)
+endfunction()
+
+function(FortranCInterface_VERIFY)
+  # Check arguments.
+
+  set(lang C)
+  set(quiet 0)
+  set(verify_cxx 0)
+  foreach(arg ${ARGN})
+    if("${arg}" STREQUAL "QUIET")
+      set(quiet 1)
+    elseif("${arg}" STREQUAL "CXX")
+      set(lang CXX)
+      set(verify_cxx 1)
+    else()
+      message(FATAL_ERROR
+        "FortranCInterface_VERIFY - called with unknown argument:\n  ${arg}")
+    endif()
+  endforeach()
+
+  if(NOT CMAKE_${lang}_COMPILER_LOADED)
+    message(FATAL_ERROR
+      "FortranCInterface_VERIFY(${lang}) requires ${lang} to be enabled.")
+  endif()
+
+  # Build the verification project if not yet built.
+  if(NOT DEFINED FortranCInterface_VERIFIED_${lang})
+    set(_desc "Verifying Fortran/${lang} Compiler Compatibility")
+    message(STATUS "${_desc}")
+
+    # Build a sample project which reports symbols.
+    try_compile(FortranCInterface_VERIFY_${lang}_COMPILED
+      ${FortranCInterface_BINARY_DIR}/Verify${lang}
+      ${FortranCInterface_SOURCE_DIR}/Verify
+      VerifyFortranC
+      CMAKE_FLAGS -DVERIFY_CXX=${verify_cxx}
+                  -DCMAKE_VERBOSE_MAKEFILE=ON
+                 "-DCMAKE_C_FLAGS:STRING=${CMAKE_C_FLAGS}"
+                 "-DCMAKE_CXX_FLAGS:STRING=${CMAKE_CXX_FLAGS}"
+                 "-DCMAKE_Fortran_FLAGS:STRING=${CMAKE_Fortran_FLAGS}"
+      OUTPUT_VARIABLE _output)
+    file(WRITE "${FortranCInterface_BINARY_DIR}/Verify${lang}/output.txt" "${_output}")
+
+    # Report results.
+    if(FortranCInterface_VERIFY_${lang}_COMPILED)
+      message(STATUS "${_desc} - Success")
+      file(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
+        "${_desc} passed with the following output:\n${_output}\n\n")
+      set(FortranCInterface_VERIFIED_${lang} 1 CACHE INTERNAL "Fortran/${lang} compatibility")
+    else()
+      message(STATUS "${_desc} - Failed")
+      file(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log
+        "${_desc} failed with the following output:\n${_output}\n\n")
+      set(FortranCInterface_VERIFIED_${lang} 0 CACHE INTERNAL "Fortran/${lang} compatibility")
+    endif()
+    unset(FortranCInterface_VERIFY_${lang}_COMPILED CACHE)
+  endif()
+
+  # Error if compilers are incompatible.
+  if(NOT FortranCInterface_VERIFIED_${lang} AND NOT quiet)
+    file(READ "${FortranCInterface_BINARY_DIR}/Verify${lang}/output.txt" _output)
+    string(REGEX REPLACE "\n" "\n  " _output "${_output}")
+    message(FATAL_ERROR
+      "The Fortran compiler:\n  ${CMAKE_Fortran_COMPILER}\n"
+      "and the ${lang} compiler:\n  ${CMAKE_${lang}_COMPILER}\n"
+      "failed to compile a simple test project using both languages.  "
+      "The output was:\n  ${_output}")
+  endif()
+endfunction()
+
+# Restore including context policies.
+cmake_policy(POP)
Index: src/matioConfig.cmake.in
===================================================================
--- src/matioConfig.cmake.in	(revision 0)
+++ src/matioConfig.cmake.in	(revision 0)
@@ -0,0 +1,68 @@
+#ifndef MATIOCONFIGURE_H
+#define MATIOCONFIGURE_H
+
+#cmakedefine MATIO_FORTRAN
+#ifdef MATIO_FORTRAN
+#include <fortran.h>
+#define FC_FUNC_(name,NAME) FC_GLOBAL(name,NAME)
+#endif
+
+#define MATIO_PLATFORM "@MATIO_PLATFORM@"
+#define MATIO_MAJOR_VERSION "@PACKAGE_VERSION_MAJOR@"
+#define MATIO_MINOR_VERSION "@PACKAGE_VERSION_MINOR@"
+#define MATIO_RELEASE_LEVEL "@PACKAGE_VERSION_PATCH@"
+
+#define SIZEOF_DOUBLE @SIZEOF_DOUBLE@
+#define SIZEOF_FLOAT @SIZEOF_FLOAT@
+#define SIZEOF_LONG @SIZEOF_LONG@
+#define SIZEOF_INT @SIZEOF_INT@
+#define SIZEOF_SHORT @SIZEOF_SHORT@
+#define SIZEOF_CHAR @SIZEOF_CHAR@
+#define SIZEOF_VOID_PTR @CMAKE_SIZEOF_VOID_P@
+
+#cmakedefine HAVE_VA_COPY 1
+#cmakedefine HAVE_VSNPRINTF 1
+#cmakedefine HAVE_SNPRINTF 1
+#cmakedefine HAVE_VASPRINTF 1
+#cmakedefine HAVE_ASPRINTF 1
+
+#cmakedefine HAVE_ZLIB 1
+#cmakedefine HAVE_INTTYPES_H 1
+#cmakedefine HAVE_STRINGS_H 1
+#cmakedefine HAVE_STDINT_H 1
+#cmakedefine STDC_HEADERS 1
+#cmakedefine HAVE_CTYPE_H 1
+#cmakedefine HAVE_STRING_H 1
+#cmakedefine HAVE_MALLOC_H 1
+
+#cmakedefine FC_FUNC
+#cmakedefine FC_FUNC_
+
+#cmakedefine LINUX
+#cmakedefine WINNT
+#cmakedefine SUN
+
+#cmakedefine HAVE_MAT_INT64_T 1
+#cmakedefine HAVE_MAT_INT32_T 1
+#cmakedefine HAVE_MAT_INT16_T 1
+#cmakedefine HAVE_MAT_INT8_T 1
+#cmakedefine HAVE_MAT_UINT64_T 1
+#cmakedefine HAVE_MAT_UINT32_T 1
+#cmakedefine HAVE_MAT_UINT16_T 1
+#cmakedefine HAVE_MAT_UINT8_T 1
+
+#define _mat_uint8_t     uint8_t
+#define _mat_uint16_t    uint16_t
+#define _mat_uint32_t    uint32_t
+#define _mat_uint64_t    uint64_t
+#define _mat_int8_t      int8_t
+#define _mat_int16_t     int16_t
+#define _mat_int32_t     int32_t
+#define _mat_int64_t     int64_t
+
+#cmakedefine EXTENDED_SPARSE 1
+
+#cmakedefine Z_PREFIX
+
+#endif  //  ! MATIOCONFIGURE_H
+
Index: src/snprintf.c
===================================================================
--- src/snprintf.c	(revision 111)
+++ src/snprintf.c	(working copy)
@@ -87,6 +87,7 @@
  *    if the C library has some snprintf functions already.
  =============================================================*/
 
+#define _GNU_SOURCE
 #include "matioConfig.h"
 #if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
 #include <string.h>
@@ -103,6 +104,9 @@
 #if defined(HAVE_STDLIB_H) || defined(STDC_HEADERS)
 #include <stdlib.h>
 #endif
+#if defined(HAVE_MALLOC_H)
+#include <malloc.h>
+#endif
 #include <stdio.h>
 
 #ifdef HAVE_LONG_DOUBLE
@@ -167,7 +171,7 @@
 static size_t dopr(char *buffer, size_t maxlen, const char *format, 
                    va_list args_in);
 static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
-                    char *value, int flags, int min, int max);
+                   const char *value, int flags, int min, int max);
 static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
                     long value, int base, int min, int max, int flags);
 static void fmtfp(char *buffer, size_t *currlen, size_t maxlen,
@@ -179,7 +183,7 @@
         char ch;
         LLONG value;
         LDOUBLE fvalue;
-        char *strvalue;
+        const char *strvalue;
         int min;
         int max;
         int state;
@@ -438,7 +442,7 @@
 }
 
 static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
-                    char *value, int flags, int min, int max)
+                   const char *value, int flags, int min, int max)
 {
         int padlen, strln;     /* amount to pad */
         int cnt = 0;
Index: src/read_data.c
===================================================================
--- src/read_data.c	(revision 111)
+++ src/read_data.c	(working copy)
@@ -3736,8 +3736,6 @@
     int inc[10] = {0,}, cnt[10] = {0,}, dimp[10] = {0,};
     size_t data_size;
 
-    int (*read_data_func)(mat_t *mat,void *data,int data_type,int len) = NULL;
-
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) ||
          (start == NULL) || (stride == NULL) || (edge    == NULL) ) {
         return -1;
@@ -4649,7 +4647,7 @@
 {
     int nBytes = 0, i, j, N, I = 0;
     int inc[10] = {0,}, cnt[10] = {0,}, dimp[10] = {0,};
-    z_stream z_copy = {0,};
+    z_stream z_copy;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) ||
          (start == NULL) || (stride == NULL) || (edge    == NULL) ) {
@@ -5991,8 +5989,8 @@
 ReadCompressedDataSlab1(mat_t *mat,z_stream *z,void *data,int class_type,
     int data_type,int start,int stride,int edge)
 {   
-    int nBytes = 0, data_size, i, err;
-    z_stream z_copy = {0,};
+    int nBytes = 0, i, err;
+    z_stream z_copy;
     
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) )
         return 0;
@@ -6161,7 +6159,7 @@
 {
     int nBytes = 0, data_size, i, j, err;
     int pos, row_stride, col_stride;
-    z_stream z_copy = {0,};
+    z_stream z_copy;
 
     if ( (mat   == NULL) || (data   == NULL) || (mat->fp == NULL) ||
          (start == NULL) || (stride == NULL) || (edge    == NULL) ) {
Index: src/mat4.c
===================================================================
--- src/mat4.c	(revision 111)
+++ src/mat4.c	(working copy)
@@ -22,6 +22,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
+#define MATIO_INTERNAL
 #include "matio.h"
 #include "mat4.h"
 #include "matio_private.h"
Index: src/mat5.c
===================================================================
--- src/mat5.c	(revision 111)
+++ src/mat5.c	(working copy)
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#define MATIO_INTERNAL
 #include "matio.h"
 #include "mat5.h"
 #include "matio_private.h"
@@ -92,13 +93,13 @@
 
     if ( matvar->class_type == MAT_C_STRUCT ) {
         matvar_t **fields = matvar->data;
-        int i, nfields;
+        int j, nfields;
         size_t maxlen = 0;
 
         nfields = matvar->nbytes / (nmemb*matvar->data_size);
-        for ( i = 0; i < nfields; i++ ) {
-            if ( NULL != fields[i]->name && strlen(fields[i]->name) > maxlen )
-                maxlen = strlen(fields[i]->name);
+        for ( j = 0; j < nfields; j++ ) {
+            if ( NULL != fields[j]->name && strlen(fields[j]->name) > maxlen )
+                maxlen = strlen(fields[j]->name);
         }
         maxlen++;
         while ( nfields*maxlen % 8 != 0 )
@@ -108,16 +109,16 @@
 
         /* FIXME: Add bytes for the fieldnames */
         if ( NULL != fields && nfields > 0 ) {
-            for ( i = 0; i < nfields*nmemb; i++ )
-                nBytes += GetStructFieldBufSize(fields[i]);
+            for ( j = 0; j < nfields*nmemb; j++ )
+                nBytes += GetStructFieldBufSize(fields[j]);
         }
     } else if ( matvar->class_type == MAT_C_CELL ) {
         matvar_t **cells = matvar->data;
-        int i, ncells = matvar->nbytes / matvar->data_size;
+        int j, ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
-            for ( i = 0; i < ncells; i++ )
-                nBytes += GetCellArrayFieldBufSize(cells[i]);
+            for ( j = 0; j < ncells; j++ )
+                nBytes += GetCellArrayFieldBufSize(cells[j]);
         }
     } else if ( matvar->class_type == MAT_C_SPARSE ) {
         sparse_t *sparse = matvar->data;
@@ -182,13 +183,13 @@
 
     if ( matvar->class_type == MAT_C_STRUCT ) {
         matvar_t **fields = matvar->data;
-        int i, nfields;
+        int j, nfields;
         size_t maxlen = 0;
 
         nfields = matvar->nbytes / (nmemb*matvar->data_size);
-        for ( i = 0; i < nfields; i++ ) {
-            if ( NULL != fields[i]->name && strlen(fields[i]->name) > maxlen )
-                maxlen = strlen(fields[i]->name);
+        for ( j = 0; j < nfields; j++ ) {
+            if ( NULL != fields[j]->name && strlen(fields[j]->name) > maxlen )
+                maxlen = strlen(fields[j]->name);
         }
         maxlen++;
         while ( nfields*maxlen % 8 != 0 )
@@ -197,16 +198,16 @@
         nBytes += tag_size + tag_size + maxlen*nfields;
 
         if ( NULL != fields && nfields > 0 ) {
-            for ( i = 0; i < nfields*nmemb; i++ )
-                nBytes += GetStructFieldBufSize(fields[i]);
+            for ( j = 0; j < nfields*nmemb; j++ )
+                nBytes += GetStructFieldBufSize(fields[j]);
         }
     } else if ( matvar->class_type == MAT_C_CELL ) {
         matvar_t **cells = matvar->data;
-        int i, ncells = matvar->nbytes / matvar->data_size;
+        int j, ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
-            for ( i = 0; i < ncells; i++ )
-                nBytes += GetCellArrayFieldBufSize(cells[i]);
+            for ( j = 0; j < ncells; j++ )
+                nBytes += GetCellArrayFieldBufSize(cells[j]);
         }
     } else if ( matvar->class_type == MAT_C_SPARSE ) {
         sparse_t *sparse = matvar->data;
@@ -268,13 +269,13 @@
 
     if ( matvar->class_type == MAT_C_STRUCT ) {
         matvar_t **fields = matvar->data;
-        int i, nfields;
+        int j, nfields;
         size_t maxlen = 0;
 
         nfields = matvar->nbytes / (nmemb*matvar->data_size);
-        for ( i = 0; i < nfields; i++ ) {
-            if ( NULL != fields[i]->name && strlen(fields[i]->name) > maxlen )
-                maxlen = strlen(fields[i]->name);
+        for ( j = 0; j < nfields; j++ ) {
+            if ( NULL != fields[j]->name && strlen(fields[j]->name) > maxlen )
+                maxlen = strlen(fields[j]->name);
         }
         maxlen++;
         while ( nfields*maxlen % 8 != 0 )
@@ -284,16 +285,16 @@
 
         /* FIXME: Add bytes for the fieldnames */
         if ( NULL != fields && nfields > 0 ) {
-            for ( i = 0; i < nfields*nmemb; i++ )
-                nBytes += GetStructFieldBufSize(fields[i]);
+            for ( j = 0; j < nfields*nmemb; j++ )
+                nBytes += GetStructFieldBufSize(fields[j]);
         }
     } else if ( matvar->class_type == MAT_C_CELL ) {
         matvar_t **cells = matvar->data;
-        int i, ncells = matvar->nbytes / matvar->data_size;
+        int j, ncells = matvar->nbytes / matvar->data_size;
 
         if ( NULL != cells && ncells > 0 ) {
-            for ( i = 0; i < ncells; i++ )
-                nBytes += GetCellArrayFieldBufSize(cells[i]);
+            for ( j = 0; j < ncells; j++ )
+                nBytes += GetCellArrayFieldBufSize(cells[j]);
         }
     } else if ( matvar->class_type == MAT_C_SPARSE ) {
         sparse_t *sparse = matvar->data;
@@ -408,7 +409,7 @@
 size_t
 WriteCompressedCharData(mat_t *mat,z_stream *z,void *data,int N,int data_type)
 {
-    int nBytes = 0, data_size, data_tag[2], err, byteswritten = 0;
+    int data_size, data_tag[2], err, byteswritten = 0;
     int buf_size = 1024, i;
     mat_uint8_t   buf[1024], pad[8] = {0,};
 
@@ -421,7 +422,7 @@
             data_size = 2;
             data_tag[0]  = MAT_T_UINT16;
             data_tag[1]  = N*data_size;
-            z->next_in   = data_tag;
+            z->next_in   = (Bytef*) data_tag;
             z->avail_in  = 8;
             z->next_out  = buf;
             z->avail_out = buf_size;
@@ -456,7 +457,7 @@
             data_size    = 2;
             data_tag[0]  = MAT_T_UINT16;
             data_tag[1]  = N*data_size;
-            z->next_in   = data_tag;
+            z->next_in   = (Bytef*) data_tag;
             z->avail_in  = 8;
             z->next_out  = buf;
             z->avail_out = buf_size;
@@ -467,7 +468,7 @@
             ptr = data;
             for ( i = 0; i < N; i++ ) {
                 c = (mat_uint16_t)*(char *)ptr;
-                z->next_in   = &c;
+                z->next_in   = (Bytef*) &c;
                 z->avail_in  = 2;
                 z->next_out  = buf;
                 z->avail_out = buf_size;
@@ -491,7 +492,7 @@
             data_size = 1;
             data_tag[0]  = MAT_T_UTF8;
             data_tag[1]  = N*data_size;
-            z->next_in   = data_tag;
+            z->next_in   = (Bytef*) data_tag;
             z->avail_in  = 8;
             z->next_out  = buf;
             z->avail_out = buf_size;
@@ -744,15 +745,15 @@
             nBytes = N*data_size;
             uncomp_buf[0] = data_type;
             uncomp_buf[1] = 0;
-            z->next_out  = comp_buf;
-            z->next_in   = uncomp_buf;
+            z->next_out  = (Bytef*) comp_buf;
+            z->next_in   = (Bytef*) uncomp_buf;
             z->avail_out = 32*sizeof(*comp_buf);
             z->avail_in  = 8;
             err = deflate(z,Z_NO_FLUSH);
             byteswritten += fwrite(comp_buf,1,32*sizeof(*comp_buf)-z->avail_out,mat->fp);
             for ( i = 0; i < N; i++ ) {
-                z->next_out  = comp_buf;
-                z->next_in   = data_uncomp_buf;
+                z->next_out  = (Bytef*) comp_buf;
+                z->next_in   = (Bytef*) data_uncomp_buf;
                 z->avail_out = 32*sizeof(*comp_buf);
                 z->avail_in  = 8;
                 err = deflate(z,Z_NO_FLUSH);
@@ -1282,7 +1283,7 @@
 
     data_tag[0]  = data_type;
     data_tag[1]  = data_size*N;
-    z->next_in   = data_tag;
+    z->next_in   = (Bytef*) data_tag;
     z->avail_in  = 8;
     z->next_out  = buf;
     z->avail_out = buf_size;
@@ -1432,23 +1433,23 @@
 #endif
 
     } else {
-        int ncells;
+        int ncells1;
         mat_uint32_t buf[16];
         int      nbytes,nBytes;
         mat_uint32_t array_flags; 
 
-        ncells = 1;
+        ncells1 = 1;
         for ( i = 0; i < matvar->rank; i++ )
-            ncells *= matvar->dims[i];
+            ncells1 *= matvar->dims[i];
         matvar->data_size = sizeof(matvar_t *);
-        matvar->nbytes    = ncells*matvar->data_size;
+        matvar->nbytes    = ncells1*matvar->data_size;
         matvar->data = malloc(matvar->nbytes);
         if ( !matvar->data ) {
             Mat_Critical("Couldn't allocate memory for %s->data",matvar->name);
             return bytesread;
         }
         cells = (matvar_t **)matvar->data;
-        for ( i = 0; i < ncells; i++ ) {
+        for ( i = 0; i < ncells1; i++ ) {
             int cell_bytes_read;
             cells[i] = Mat_VarCalloc();
             if ( !cells[i] ) {
@@ -1565,7 +1566,7 @@
 #if defined(HAVE_ZLIB)
         char    *ptr;
         mat_uint32_t uncomp_buf[16] = {0,};
-        int      nbytes, j, nmemb = 1;
+        int      nbytes, nmemb = 1;
         mat_uint32_t array_flags; 
 
         for ( i = 0; i < matvar->rank; i++ )
@@ -1610,6 +1611,7 @@
             fields[i]->name[fieldname_size-1] = '\0';
         }
         for ( i = 1; i < nmemb; i++ ) {
+            int j;
             for ( j = 0; j < nfields; j++ ) {
                 fields[i*nfields+j] = calloc(1,sizeof(matvar_t));
                 fields[i*nfields+j]->name = strdup_printf("%s",fields[j]->name);
@@ -1703,9 +1705,8 @@
         Mat_Critical("Not compiled with zlib support");
 #endif
     } else {
-        int fieldname_size,nfields;
         mat_uint32_t buf[16] = {0,};
-        int      nbytes,nBytes,nmemb=1,j;
+        int      nbytes,nBytes,nmemb=1;
         mat_uint32_t array_flags; 
 
         for ( i = 0; i < matvar->rank; i++ )
@@ -1742,6 +1743,7 @@
             fields[i]->name[fieldname_size-1] = '\0';
         }
         for ( i = 1; i < nmemb; i++ ) {
+            int j;
             for ( j = 0; j < nfields; j++ ) {
                 fields[i*nfields+j] = calloc(1,sizeof(matvar_t));
                 fields[i*nfields+j]->name = strdup_printf("%s",fields[j]->name);
@@ -1940,7 +1942,7 @@
         fwrite(&pad4,4,1,mat->fp);
     } else if ( strlen(matvar->name) <= 4 ) {
         mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);
-        mat_int8_t  pad1 = 0;
+        pad1 = 0;
         fwrite(&array_name_type,2,1,mat->fp);
         fwrite(&array_name_len,2,1,mat->fp);
         fwrite(matvar->name,1,array_name_len,mat->fp);
@@ -1948,7 +1950,7 @@
             fwrite(&pad1,1,1,mat->fp);
     } else {
         mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);
-        mat_int8_t  pad1 = 0;
+        pad1 = 0;
 
         fwrite(&array_name_type,2,1,mat->fp);
         fwrite(&pad1,1,1,mat->fp);
@@ -2078,7 +2080,7 @@
         fwrite(&pad4,4,1,mat->fp);
     } else if ( strlen(matvar->name) <= 4 ) {
         mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);
-        mat_int8_t  pad1 = 0;
+        pad1 = 0;
         fwrite(&array_name_type,2,1,mat->fp);
         fwrite(&array_name_len,2,1,mat->fp);
         fwrite(matvar->name,1,array_name_len,mat->fp);
@@ -2086,7 +2088,7 @@
             fwrite(&pad1,1,1,mat->fp);
     } else {
         mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);
-        mat_int8_t  pad1 = 0;
+        pad1 = 0;
 
         fwrite(&array_name_type,2,1,mat->fp);
         fwrite(&pad1,1,1,mat->fp);
@@ -2228,7 +2230,6 @@
     mat_int16_t  fieldname_data_size = 4;
     int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
     int      array_flags_size = 8, pad4 = 0;
-    mat_int8_t   pad1 = 0;
     int      nBytes, i, nmemb = 1, nzmax = 0;
     long     start = 0;
 
@@ -2255,8 +2256,8 @@
 
     uncomp_buf[0] = MAT_T_MATRIX;
     uncomp_buf[1] = (int)GetMatrixMaxBufSize(matvar);
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = 8;
     err = deflate(z,Z_NO_FLUSH);
@@ -2281,8 +2282,8 @@
         i++;
     }
 
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = (6+i)*sizeof(*uncomp_buf);
     err = deflate(z,Z_NO_FLUSH);
@@ -2291,8 +2292,8 @@
     /* Name of variable */
     uncomp_buf[0] = array_name_type;
     uncomp_buf[1] = 0;
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = 8;
     err = deflate(z,Z_NO_FLUSH);
@@ -2353,7 +2354,7 @@
             unsigned char *padzero;
             int        fieldname_size, nfields;
             size_t     maxlen = 0;
-            mat_int32_t array_name_type = MAT_T_INT8;
+            array_name_type = MAT_T_INT8;
             matvar_t **fields = (matvar_t **)matvar->data;
 
             /* Check for a structure with no fields */
@@ -2365,8 +2366,8 @@
                 uncomp_buf[1] = 1;
                 uncomp_buf[2] = array_name_type;
                 uncomp_buf[3] = 0;
-                z->next_out  = comp_buf;
-                z->next_in   = uncomp_buf;
+                z->next_out  = (Bytef*) comp_buf;
+                z->next_in   = (Bytef*) uncomp_buf;
                 z->avail_out = buf_size*sizeof(*comp_buf);
                 z->avail_in  = 32;
                 err = deflate(z,Z_NO_FLUSH);
@@ -2391,8 +2392,8 @@
             uncomp_buf[3] = nfields*fieldname_size;
 
             padzero = calloc(fieldname_size,1);
-            z->next_out  = comp_buf;
-            z->next_in   = uncomp_buf;
+            z->next_out  = (Bytef*) comp_buf;
+            z->next_in   = (Bytef*) uncomp_buf;
             z->avail_out = buf_size*sizeof(*comp_buf);
             z->avail_in  = 16;
             err = deflate(z,Z_NO_FLUSH);
@@ -2401,7 +2402,7 @@
             for ( i = 0; i < nfields; i++ ) {
                 memset(padzero,'\0',fieldname_size);
                 memcpy(padzero,fieldnames[i],strlen(fieldnames[i]));
-                z->next_out  = comp_buf;
+                z->next_out  = (Bytef*) comp_buf;
                 z->next_in   = padzero;
                 z->avail_out = buf_size*sizeof(*comp_buf);
                 z->avail_in  = fieldname_size;
@@ -2638,7 +2639,6 @@
     mat_int16_t  fieldname_data_size = 4;
     int      array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;
     int      array_flags_size = 8, pad4 = 0;
-    mat_int8_t   pad1 = 0;
     int      nBytes, i, nmemb = 1, nzmax = 0;
     long     start = 0;
 
@@ -2665,8 +2665,8 @@
 
     uncomp_buf[0] = MAT_T_MATRIX;
     uncomp_buf[1] = (int)GetMatrixMaxBufSize(matvar);
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = 8;
     err = deflate(z,Z_NO_FLUSH);
@@ -2691,8 +2691,8 @@
         i++;
     }
 
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = (6+i)*sizeof(*uncomp_buf);
     err = deflate(z,Z_NO_FLUSH);
@@ -2701,8 +2701,8 @@
     /* Name of variable */
     uncomp_buf[0] = array_name_type;
     uncomp_buf[1] = 0;
-    z->next_out  = comp_buf;
-    z->next_in   = uncomp_buf;
+    z->next_out  = (Bytef*) comp_buf;
+    z->next_in   = (Bytef*) uncomp_buf;
     z->avail_out = buf_size*sizeof(*comp_buf);
     z->avail_in  = 8;
     err = deflate(z,Z_NO_FLUSH);
@@ -2763,7 +2763,7 @@
             unsigned char *padzero;
             int        fieldname_size, nfields;
             size_t     maxlen = 0;
-            mat_int32_t array_name_type = MAT_T_INT8;
+            array_name_type = MAT_T_INT8;
             matvar_t **fields = (matvar_t **)matvar->data;
 
             /* Check for a structure with no fields */
@@ -2775,8 +2775,8 @@
                 uncomp_buf[1] = 1;
                 uncomp_buf[2] = array_name_type;
                 uncomp_buf[3] = 0;
-                z->next_out  = comp_buf;
-                z->next_in   = uncomp_buf;
+                z->next_out  = (Bytef*) comp_buf;
+                z->next_in   = (Bytef*) uncomp_buf;
                 z->avail_out = buf_size*sizeof(*comp_buf);
                 z->avail_in  = 32;
                 err = deflate(z,Z_NO_FLUSH);
@@ -2801,8 +2801,8 @@
             uncomp_buf[3] = nfields*fieldname_size;
 
             padzero = calloc(fieldname_size,1);
-            z->next_out  = comp_buf;
-            z->next_in   = uncomp_buf;
+            z->next_out  = (Bytef*) comp_buf;
+            z->next_in   = (Bytef*) uncomp_buf;
             z->avail_out = buf_size*sizeof(*comp_buf);
             z->avail_in  = 16;
             err = deflate(z,Z_NO_FLUSH);
@@ -2811,7 +2811,7 @@
             for ( i = 0; i < nfields; i++ ) {
                 memset(padzero,'\0',fieldname_size);
                 memcpy(padzero,fieldnames[i],strlen(fieldnames[i]));
-                z->next_out  = comp_buf;
+                z->next_out  = (Bytef*) comp_buf;
                 z->next_in   = padzero;
                 z->avail_out = buf_size*sizeof(*comp_buf);
                 z->avail_in  = fieldname_size;
@@ -5292,7 +5292,6 @@
     } else {
         if ( matvar->compression == COMPRESSION_NONE ) {
             if ( matvar->isComplex ) {
-                int i;
                 struct ComplexSplit *complex_data = data;
 
                 ReadDataSlabN(mat,complex_data->Re,matvar->class_type,
@@ -5320,7 +5319,6 @@
 #if defined(HAVE_ZLIB)
         else if ( matvar->compression == COMPRESSION_ZLIB ) {
             if ( matvar->isComplex ) {
-                int i;
                 struct ComplexSplit *complex_data = data;
 
                 ReadCompressedDataSlabN(mat,&z,complex_data->Re,
@@ -5411,12 +5409,12 @@
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
- * @param compress option to compress the variable
+ * @param comp option to compress the variable
  *                 (only works for numeric types)
  * @retval 0 on success
  */
 int
-Write5(mat_t *mat,matvar_t *matvar,int compress)
+Write5(mat_t *mat,matvar_t *matvar,int comp)
 {
     mat_uint32_t array_flags = 0x0;
     mat_int16_t  fieldname_type = MAT_T_INT32,fieldname_data_size=4;
@@ -5430,7 +5428,7 @@
     fseek(mat->fp,0,SEEK_END);         /* Always write at end of file */
 
 
-    if ( compress == COMPRESSION_NONE ) {
+    if ( comp == COMPRESSION_NONE ) {
         fwrite(&matrix_type,4,1,mat->fp);
         fwrite(&pad4,4,1,mat->fp);
         start = ftell(mat->fp);
@@ -5467,7 +5465,6 @@
         if ( strlen(matvar->name) <= 4 ) {
             mat_int32_t  array_name_type = MAT_T_INT8;
             mat_int32_t array_name_len   = strlen(matvar->name);
-            mat_int8_t  pad1 = 0;
 #if 0
             fwrite(&array_name_type,2,1,mat->fp);
             fwrite(&array_name_len,2,1,mat->fp);
@@ -5481,7 +5478,6 @@
         } else {
             mat_int32_t array_name_type = MAT_T_INT8;
             mat_int32_t array_name_len  = (mat_int32_t)strlen(matvar->name);
-            mat_int8_t  pad1 = 0;
 
             fwrite(&array_name_type,4,1,mat->fp);
             fwrite(&array_name_len,4,1,mat->fp);
@@ -5635,7 +5631,7 @@
             }
         }
 #if defined(HAVE_ZLIB)
-    } else if ( compress == COMPRESSION_ZLIB ) {
+    } else if ( comp == COMPRESSION_ZLIB ) {
         mat_uint32_t comp_buf[512];
         mat_uint32_t uncomp_buf[512] = {0,};
         int buf_size = 512, err;
@@ -5664,8 +5660,8 @@
 
         uncomp_buf[0] = MAT_T_MATRIX;
         uncomp_buf[1] = (int)GetMatrixMaxBufSize(matvar);
-        matvar->z->next_out  = comp_buf;
-        matvar->z->next_in   = uncomp_buf;
+        matvar->z->next_out  = (Bytef*) comp_buf;
+        matvar->z->next_in   = (Bytef*) uncomp_buf;
         matvar->z->avail_out = buf_size*sizeof(*comp_buf);
         matvar->z->avail_in  = 8;
         err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5690,8 +5686,8 @@
             i++;
         }
 
-        matvar->z->next_out  = comp_buf;
-        matvar->z->next_in   = uncomp_buf;
+        matvar->z->next_out  = (Bytef*) comp_buf;
+        matvar->z->next_in   = (Bytef*) uncomp_buf;
         matvar->z->avail_out = buf_size*sizeof(*comp_buf);
         matvar->z->avail_in  = (6+i)*sizeof(*uncomp_buf);
         err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5708,8 +5704,8 @@
             if ( array_name_len % 4 )
                 array_name_len += 4-(array_name_len % 4);
 
-            matvar->z->next_out  = comp_buf;
-            matvar->z->next_in   = uncomp_buf;
+            matvar->z->next_out  = (Bytef*) comp_buf;
+            matvar->z->next_in   = (Bytef*) uncomp_buf;
             matvar->z->avail_out = buf_size*sizeof(*comp_buf);
             matvar->z->avail_in  = 8;
             err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5725,8 +5721,8 @@
             memcpy(uncomp_buf+2,matvar->name,array_name_len);
             if ( array_name_len % 8 )
                 array_name_len += 8-(array_name_len % 8);
-            matvar->z->next_out  = comp_buf;
-            matvar->z->next_in   = uncomp_buf;
+            matvar->z->next_out  = (Bytef*) comp_buf;
+            matvar->z->next_in   = (Bytef*) uncomp_buf;
             matvar->z->avail_out = buf_size*sizeof(*comp_buf);
             matvar->z->avail_in  = 8+array_name_len;
             err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5799,8 +5795,8 @@
                     uncomp_buf[1] = 1;
                     uncomp_buf[2] = array_name_type;
                     uncomp_buf[3] = 0;
-                    matvar->z->next_out  = comp_buf;
-                    matvar->z->next_in   = uncomp_buf;
+                    matvar->z->next_out  = (Bytef*) comp_buf;
+                    matvar->z->next_in   = (Bytef*) uncomp_buf;
                     matvar->z->avail_out = buf_size*sizeof(*comp_buf);
                     matvar->z->avail_in  = 32;
                     err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5825,8 +5821,8 @@
                 uncomp_buf[3] = nfields*fieldname_size;
 
                 padzero = calloc(fieldname_size,1);
-                matvar->z->next_out  = comp_buf;
-                matvar->z->next_in   = uncomp_buf;
+                matvar->z->next_out  = (Bytef*) comp_buf;
+                matvar->z->next_in   = (Bytef*) uncomp_buf;
                 matvar->z->avail_out = buf_size*sizeof(*comp_buf);
                 matvar->z->avail_in  = 16;
                 err = deflate(matvar->z,Z_NO_FLUSH);
@@ -5835,7 +5831,7 @@
                 for ( i = 0; i < nfields; i++ ) {
                     memset(padzero,'\0',fieldname_size);
                     memcpy(padzero,fieldnames[i],strlen(fieldnames[i]));
-                    matvar->z->next_out  = comp_buf;
+                    matvar->z->next_out  = (Bytef*) comp_buf;
                     matvar->z->next_in   = padzero;
                     matvar->z->avail_out = buf_size*sizeof(*comp_buf);
                     matvar->z->avail_in  = fieldname_size;
@@ -5874,14 +5870,14 @@
         }
         matvar->z->avail_in  = 0;
         matvar->z->next_in   = NULL;
-        matvar->z->next_out  = comp_buf;
+        matvar->z->next_out  = (Bytef*) comp_buf;
         matvar->z->avail_out = buf_size*sizeof(*comp_buf);
 
         err = deflate(matvar->z,Z_FINISH);
         byteswritten += fwrite(comp_buf,1,
             buf_size*sizeof(*comp_buf)-matvar->z->avail_out,mat->fp);
         while ( err != Z_STREAM_END && !matvar->z->avail_out ) {
-            matvar->z->next_out  = comp_buf;
+            matvar->z->next_out  = (Bytef*) comp_buf;
             matvar->z->avail_out = buf_size*sizeof(*comp_buf);
 
             err = deflate(matvar->z,Z_FINISH);
@@ -5967,7 +5963,6 @@
         /* Name of variable */
         if ( strlen(matvar->name) <= 4 ) {
             mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);
-            mat_int8_t  pad1 = 0;
             mat_int16_t array_name_type = MAT_T_INT8;
             fwrite(&array_name_type,2,1,mat->fp);
             fwrite(&array_name_len,2,1,mat->fp);
@@ -5976,7 +5971,6 @@
                 fwrite(&pad1,1,1,mat->fp);
         } else {
             mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);
-            mat_int8_t  pad1 = 0;
             mat_int32_t  array_name_type = MAT_T_INT8;
 
             fwrite(&array_name_type,4,1,mat->fp);
@@ -6027,7 +6021,7 @@
             case MAT_C_STRUCT:
             {
                 char **fieldnames, *padzero;
-                int maxlen = 0, fieldname_size;
+                size_t maxlen = 0, fieldname_size;
                 int nfields = matvar->nbytes / matvar->data_size;
                 matvar_t **fields = (matvar_t **)matvar->data;
                 mat_int32_t  array_name_type = MAT_T_INT8;
@@ -6312,7 +6306,7 @@
                          (matvar->dims[0] > 15 || matvar->dims[1] > 15) ) {
                     for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ )
-                            printf("%d ", ((mat_int64_t*)matvar->data)[matvar->dims[0]*j+i]);
+                            printf("%d ", (int)(((mat_int64_t*)matvar->data)[matvar->dims[0]*j+i]));
                         if ( j < matvar->dims[1] )
                             printf("...");
                         printf("\n");
@@ -6322,12 +6316,12 @@
                 } else if ( matvar->rank == 2 ) {
                     for ( i = 0; i < matvar->dims[0]; i++ ) {
                         for ( j = 0; j < matvar->dims[1]; j++ )
-                            printf("%d ", ((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]);
+                            printf("%u ", (unsigned)(((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]));
                         printf("\n");
                     }
                 } else {
                     for ( i = 0; i < matvar->nbytes/matvar->data_size; i++ )
-                        printf("%d\n", ((mat_int64_t*)matvar->data)[i]);
+                        printf("%d\n", (int) (((mat_int64_t*)matvar->data)[i]));
                 }
                 break;
 #endif
@@ -6343,7 +6337,7 @@
                          (matvar->dims[0] > 15 || matvar->dims[1] > 15) ) {
                     for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ )
-                            printf("%u ", ((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]);
+                            printf("%u ", (unsigned) (((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]));
                         if ( j < matvar->dims[1] )
                             printf("...");
                         printf("\n");
@@ -6353,12 +6347,12 @@
                 } else if ( matvar->rank == 2 ) {
                     for ( i = 0; i < matvar->dims[0]; i++ ) {
                         for ( j = 0; j < matvar->dims[1]; j++ )
-                            printf("%u ", ((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]);
+                            printf("%u ", (unsigned) (((mat_uint64_t*)matvar->data)[matvar->dims[0]*j+i]));
                         printf("\n");
                     }
                 } else {
                     for ( i = 0; i < matvar->nbytes/matvar->data_size; i++ )
-                        printf("%u\n", ((mat_int64_t*)matvar->data)[i]);
+                        printf("%u\n", (unsigned) (((mat_int64_t*)matvar->data)[i]));
                 }
                 break;
 #endif /* HAVE_MAT_UINT64_T */
@@ -7003,14 +6997,14 @@
         {
             int      nbytes;
             mat_uint32_t buf[32];
-            size_t   bytesread = 0;
+            size_t   bytesread1 = 0;
 
             matvar = Mat_VarCalloc();
             matvar->fpos         = fpos;
             matvar->fp           = mat;
 
             /* Read Array Flags and The Dimensions Tag */
-            bytesread  += fread(buf,4,6,mat->fp);
+            bytesread1  += fread(buf,4,6,mat->fp);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
@@ -7040,9 +7034,9 @@
 
                 /* Assumes rank <= 16 */
                 if ( matvar->rank % 2 != 0 )
-                    bytesread+=fread(buf,4,matvar->rank+1,mat->fp);
+                    bytesread1+=fread(buf,4,matvar->rank+1,mat->fp);
                 else
-                    bytesread+=fread(buf,4,matvar->rank,mat->fp);
+                    bytesread1+=fread(buf,4,matvar->rank,mat->fp);
 
                 if ( mat->byteswap ) {
                     for ( i = 0; i < matvar->rank; i++ )
@@ -7053,7 +7047,7 @@
                 }
             }
             /* Variable Name Tag */
-            bytesread+=fread(buf,4,2,mat->fp);
+            bytesread1+=fread(buf,4,2,mat->fp);
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(buf);
             /* Name of variable */
@@ -7068,7 +7062,7 @@
                     i = len;
                 else
                     i = len+(8-(len % 8));
-                bytesread+=fread(buf,1,i,mat->fp);
+                bytesread1+=fread(buf,1,i,mat->fp);
 
                 matvar->name = malloc(len+1);
                 memcpy(matvar->name,buf,len);
Index: src/io.c
===================================================================
--- src/io.c	(revision 111)
+++ src/io.c	(working copy)
@@ -24,7 +24,9 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
+#define MATIO_INTERNAL
 #include <matio.h>
+#include <matio_private.h>
 
 #if !defined(HAVE_VA_COPY) && defined(HAVE___VA_COPY)
 #    define va_copy(d,s) __va_copy(d,s)
@@ -345,7 +347,7 @@
  * @return 0 on success
  */
 int
-Mat_LogInit( char *prog_name )
+Mat_LogInit(char* UNUSED(prog_name))
 {
     logfunc = &matio_error_func;
 
Index: src/matio_private.h
===================================================================
--- src/matio_private.h	(revision 111)
+++ src/matio_private.h	(working copy)
@@ -28,6 +28,15 @@
 #   endif
 #endif
 
+#ifdef UNUSED
+#elif defined(__GNUC__)
+# define UNUSED(x) UNUSED_ ## x __attribute__((unused))
+#elif defined(__LCLINT__)
+# define UNUSED(x) /*@unused@*/ x
+#else
+# define UNUSED(x) x
+#endif
+
 /*    snprintf.c    */
 EXTERN int mat_snprintf(char *str,size_t count,const char *fmt,...);
 EXTERN int mat_asprintf(char **ptr,const char *format, ...);
@@ -52,6 +61,7 @@
 EXTERN int ReadDoubleData(mat_t *mat,double  *data,int data_type,int len);
 EXTERN int ReadSingleData(mat_t *mat,float   *data,int data_type,int len);
 EXTERN int ReadInt32Data (mat_t *mat,mat_int32_t *data,int data_type,int len);
+EXTERN int ReadInt64Data(mat_t *mat,mat_int64_t *data,int data_type,int len);
 EXTERN int ReadUInt32Data(mat_t *mat,mat_uint32_t *data,int data_type,int len);
 EXTERN int ReadInt16Data (mat_t *mat,mat_int16_t *data,int data_type,int len);
 EXTERN int ReadUInt16Data(mat_t *mat,mat_uint16_t *data,int data_type,int len);
@@ -71,6 +81,8 @@
                int data_type,int len);
 EXTERN int ReadCompressedInt32Data(mat_t *mat,z_stream *z,mat_int32_t *data,
                int data_type,int len);
+EXTERN int ReadCompressedInt64Data(mat_t *mat,z_stream *z,mat_int64_t *data,
+               int data_type,int len);
 EXTERN int ReadCompressedUInt32Data(mat_t *mat,z_stream *z,mat_uint32_t *data,
                int data_type,int len);
 EXTERN int ReadCompressedInt16Data(mat_t *mat,z_stream *z,mat_int16_t *data,
Index: src/matio.h
===================================================================
--- src/matio.h	(revision 111)
+++ src/matio.h	(working copy)
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include "matioConfig.h"
+#include "DLLDefines.h"
 #if defined(HAVE_INTTYPES_H)
 #   include <inttypes.h>
 #endif
@@ -187,7 +188,7 @@
  * Complex data type using split real/imaginary pointers
  * @ingroup MAT
  */
-struct ComplexSplit {
+struct MATIO_EXPORT ComplexSplit {
     void *Re; /**< Pointer to the real part */
     void *Im; /**< Pointer to the imaginary part */
 };
@@ -197,7 +198,7 @@
  * Contains information about a Matlab MAT file
  * @ingroup MAT
  */
-typedef struct mat_t {
+typedef struct MATIO_EXPORT mat_t {
     FILE *fp;               /**< Pointer to the MAT file */
     char *header;           /**< MAT File header string */
     char *subsys_offset;    /**< offset */
@@ -213,7 +214,7 @@
  * Contains information about a Matlab variable
  * @ingroup MAT
  */
-typedef struct matvar_t {
+typedef struct MATIO_EXPORT matvar_t {
     int   nbytes;       /**< Number of bytes for the MAT variable */
     int   rank;         /**< Rank (Number of dimensions) of the data */
     int   data_type;    /**< Data type(MAT_T_*) */
@@ -240,7 +241,7 @@
  * Contains information and data for a sparse matrix
  * @ingroup MAT
  */
-typedef struct sparse_t {
+typedef struct MATIO_EXPORT sparse_t {
     int nzmax;               /**< Maximum number of non-zero elements */
     int *ir;                 /**< Array of size nzmax where ir[k] is the row of
                                *  data[k].  0 <= k <= nzmax
@@ -256,68 +257,68 @@
 } sparse_t;
 
 /*     io.c         */
-EXTERN char  *strdup_vprintf(const char *format, va_list ap);
-EXTERN char  *strdup_printf(const char *format, ...);
-EXTERN int    Mat_SetVerbose( int verb, int s );
-EXTERN int    Mat_SetDebug( int d );
-EXTERN void   Mat_Critical( const char *format, ... );
-EXTERN void   Mat_Error( const char *format, ... );
-EXTERN void   Mat_Help( const char *helpstr[] );
-EXTERN int    Mat_LogInit( char *progname );
-EXTERN int    Mat_LogClose(void);
-EXTERN int    Mat_LogInitFunc(char *prog_name,
-                    void (*log_func)(int log_level, char *message) );
-EXTERN int    Mat_Message( const char *format, ... );
-EXTERN int    Mat_DebugMessage( int level, const char *format, ... );
-EXTERN int    Mat_VerbMessage( int level, const char *format, ... );
-EXTERN void   Mat_Warning( const char *format, ... );
-EXTERN size_t Mat_SizeOf(int data_type);
-EXTERN size_t Mat_SizeOfClass(int class_type);
+EXTERN MATIO_EXPORT char  *strdup_vprintf(const char *format, va_list ap);
+EXTERN MATIO_EXPORT char  *strdup_printf(const char *format, ...);
+EXTERN MATIO_EXPORT int    Mat_SetVerbose( int verb, int s );
+EXTERN MATIO_EXPORT int    Mat_SetDebug( int d );
+EXTERN MATIO_EXPORT void   Mat_Critical( const char *format, ... );
+EXTERN MATIO_EXPORT void   Mat_Error( const char *format, ... );
+EXTERN MATIO_EXPORT void   Mat_Help( const char *helpstr[] );
+EXTERN MATIO_EXPORT int    Mat_LogInit( char *progname );
+EXTERN MATIO_EXPORT int    Mat_LogClose(void);
+EXTERN MATIO_EXPORT int    Mat_LogInitFunc(char *prog_name,
+                                           void (*log_func)(int log_level, char *message) );
+EXTERN MATIO_EXPORT int    Mat_Message( const char *format, ... );
+EXTERN MATIO_EXPORT int    Mat_DebugMessage( int level, const char *format, ... );
+EXTERN MATIO_EXPORT int    Mat_VerbMessage( int level, const char *format, ... );
+EXTERN MATIO_EXPORT void   Mat_Warning( const char *format, ... );
+EXTERN MATIO_EXPORT size_t Mat_SizeOf(int data_type);
+EXTERN MATIO_EXPORT size_t Mat_SizeOfClass(int class_type);
 
 /*   MAT File functions   */
-EXTERN mat_t  *Mat_Create(const char *matname,const char *hdr_str);
-EXTERN int     Mat_Close(mat_t *mat);
-EXTERN mat_t  *Mat_Open(const char *matname,int mode);
-EXTERN int     Mat_Rewind(mat_t *mat);
+EXTERN MATIO_EXPORT mat_t  *Mat_Create(const char *matname,const char *hdr_str);
+EXTERN MATIO_EXPORT int     Mat_Close(mat_t *mat);
+EXTERN MATIO_EXPORT mat_t  *Mat_Open(const char *matname,int mode);
+EXTERN MATIO_EXPORT int     Mat_Rewind(mat_t *mat);
 
 /* MAT variable functions */
-EXTERN matvar_t  *Mat_VarCalloc(void);
-EXTERN matvar_t  *Mat_VarCreate(const char *name,int class_type,int data_type,
-                      int rank,int *dims,void *data, int opt);
-EXTERN int        Mat_VarDelete(mat_t *mat, char *name);
-EXTERN matvar_t  *Mat_VarDuplicate(const matvar_t *in, int opt);
-EXTERN void       Mat_VarFree(matvar_t *matvar);
-EXTERN matvar_t  *Mat_VarGetCell(matvar_t *matvar,int index);
-EXTERN matvar_t **Mat_VarGetCells(matvar_t *matvar,int *start,int *stride,
-                      int *edge);
-EXTERN matvar_t **Mat_VarGetCellsLinear(matvar_t *matvar,int start,int stride,
-                      int edge);
-EXTERN size_t     Mat_VarGetSize(matvar_t *matvar);
-EXTERN int        Mat_VarGetNumberOfFields(matvar_t *matvar);
-EXTERN int        Mat_VarAddStructField(matvar_t *matvar,matvar_t **fields);
-EXTERN matvar_t  *Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,
-                      int opt,int index);
-EXTERN matvar_t  *Mat_VarGetStructs(matvar_t *matvar,int *start,int *stride,
-                      int *edge,int copy_fields);
-EXTERN matvar_t  *Mat_VarGetStructsLinear(matvar_t *matvar,int start,int stride,
-                      int edge,int copy_fields);
-EXTERN void       Mat_VarPrint( matvar_t *matvar, int printdata );
-EXTERN matvar_t  *Mat_VarRead(mat_t *mat, char *name );
-EXTERN int        Mat_VarReadData(mat_t *mat,matvar_t *matvar,void *data,
-                      int *start,int *stride,int *edge);
-EXTERN int        Mat_VarReadDataAll(mat_t *mat,matvar_t *matvar);
-EXTERN int        Mat_VarReadDataLinear(mat_t *mat,matvar_t *matvar,void *data,
-                      int start,int stride,int edge);
-EXTERN matvar_t  *Mat_VarReadInfo( mat_t *mat, char *name );
-EXTERN matvar_t  *Mat_VarReadNext( mat_t *mat );
-EXTERN matvar_t  *Mat_VarReadNextInfo( mat_t *mat );
-EXTERN int        Mat_VarWrite(mat_t *mat,matvar_t *matvar,int compress );
-EXTERN int        Mat_VarWriteInfo(mat_t *mat,matvar_t *matvar);
-EXTERN int        Mat_VarWriteData(mat_t *mat,matvar_t *matvar,void *data,
-                      int *start,int *stride,int *edge);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarCalloc(void);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarCreate(const char *name,int class_type,int data_type,
+                                             int rank,int *dims,void *data, int opt);
+EXTERN MATIO_EXPORT int        Mat_VarDelete(mat_t *mat, char *name);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarDuplicate(const matvar_t *in, int opt);
+EXTERN MATIO_EXPORT void       Mat_VarFree(matvar_t *matvar);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarGetCell(matvar_t *matvar,int index);
+EXTERN MATIO_EXPORT matvar_t **Mat_VarGetCells(matvar_t *matvar,int *start,int *stride,
+                                               int *edge);
+EXTERN MATIO_EXPORT matvar_t **Mat_VarGetCellsLinear(matvar_t *matvar,int start,int stride,
+                                                     int edge);
+EXTERN MATIO_EXPORT size_t     Mat_VarGetSize(matvar_t *matvar);
+EXTERN MATIO_EXPORT int        Mat_VarGetNumberOfFields(matvar_t *matvar);
+EXTERN MATIO_EXPORT int        Mat_VarAddStructField(matvar_t *matvar,matvar_t **fields);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,
+                                                     int opt,int index);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarGetStructs(matvar_t *matvar,int *start,int *stride,
+                                                 int *edge,int copy_fields);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarGetStructsLinear(matvar_t *matvar,int start,int stride,
+                                                       int edge,int copy_fields);
+EXTERN MATIO_EXPORT void       Mat_VarPrint( matvar_t *matvar, int printdata );
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarRead(mat_t *mat, char *name );
+EXTERN MATIO_EXPORT int        Mat_VarReadData(mat_t *mat,matvar_t *matvar,void *data,
+                                               int *start,int *stride,int *edge);
+EXTERN MATIO_EXPORT int        Mat_VarReadDataAll(mat_t *mat,matvar_t *matvar);
+EXTERN MATIO_EXPORT int        Mat_VarReadDataLinear(mat_t *mat,matvar_t *matvar,void *data,
+                                                     int start,int stride,int edge);
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarReadInfo( mat_t *mat, char *name );
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarReadNext( mat_t *mat );
+EXTERN MATIO_EXPORT matvar_t  *Mat_VarReadNextInfo( mat_t *mat );
+EXTERN MATIO_EXPORT int        Mat_VarWrite(mat_t *mat,matvar_t *matvar,int compress );
+EXTERN MATIO_EXPORT int        Mat_VarWriteInfo(mat_t *mat,matvar_t *matvar);
+EXTERN MATIO_EXPORT int        Mat_VarWriteData(mat_t *mat,matvar_t *matvar,void *data,
+                                                int *start,int *stride,int *edge);
 
 /* Other functions */
-EXTERN int       Mat_CalcSingleSubscript(int rank,int *dims,int *subs);
-EXTERN int      *Mat_CalcSubscripts(int rank,int *dims,int index);
+EXTERN MATIO_EXPORT int       Mat_CalcSingleSubscript(int rank,int *dims,int *subs);
+EXTERN MATIO_EXPORT int      *Mat_CalcSubscripts(int rank,int *dims,int index);
 
 #endif
Index: src/DLLDefines.h
===================================================================
--- src/DLLDefines.h	(revision 0)
+++ src/DLLDefines.h	(revision 0)
@@ -0,0 +1,23 @@
+// Contents of DLLDefines.h
+#ifndef MATIO_DLLDEFINES_H_
+#define MATIO_DLLDEFINES_H_
+
+/* Cmake will define MATIO_EXPORTS on Windows when it
+configures to build a shared library. If you are going to use
+another build system on windows or create the visual studio
+projects by hand you need to define MyLibrary_EXPORTS when
+building a DLL on windows.
+*/
+// We are using the Visual Studio Compiler and building Shared libraries
+
+#if defined (WIN32) 
+  #if defined(MATIO_INTERNAL)
+    #define  MATIO_EXPORT __declspec(dllexport)
+  #else
+    #define  MATIO_EXPORT __declspec(dllimport)
+  #endif /* matio_EXPORTS */
+#else /* defined (WIN32) */
+ #define MATIO_EXPORT
+#endif
+
+#endif /* MATIO_DLLDEFINES_H_ */
Index: src/mat.c
===================================================================
--- src/mat.c	(revision 111)
+++ src/mat.c	(working copy)
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#define MATIO_INTERNAL
 #include "matio.h"
 #include "mat5.h"
 #include "mat4.h"
@@ -804,7 +805,7 @@
 int
 Mat_CalcSingleSubscript(int rank,int *dims,int *subs)
 {
-    int index = 0, i, j, k, err = 0;
+    int ind = 0, i, j, k, err = 0;
 
     for ( i = 0; i < rank; i++ ) {
         k = subs[i];
@@ -819,12 +820,12 @@
         k--;
         for ( j = i; j--; )
             k *= dims[j];
-        index += k;
+        ind += k;
     }
     if ( err )
-        index = -1;
+        ind = -1;
 
-    return index;
+    return ind;
 }
 
 
@@ -843,17 +844,17 @@
  * @ingroup MAT
  * @param rank Rank of the variable
  * @param dims dimensions of the variable
- * @param index linear index
+ * @param ind linear index
  * @return Array of dimension subscripts
  */
 int *
-Mat_CalcSubscripts(int rank,int *dims,int index)
+Mat_CalcSubscripts(int rank,int *dims,int ind)
 {
     int i, j, k, *subs;
     double l;
 
     subs = malloc(rank*sizeof(int));
-    l = index;
+    l = ind;
     for ( i = rank; i--; ) {
         k = 1;
         for ( j = i; j--; )
@@ -872,11 +873,11 @@
  * MAT file must be a version 5 matlab file.
  * @ingroup MAT
  * @param matvar Pointer to the Cell Array MAT variable
- * @param index linear index of cell to return
+ * @param ind linear index of cell to return
  * @return Pointer to the Cell Array Field on success, NULL on error
  */
 matvar_t *
-Mat_VarGetCell(matvar_t *matvar,int index)
+Mat_VarGetCell(matvar_t *matvar,int ind)
 {
     int       nmemb = 1, i;
     matvar_t *cell = NULL;
@@ -887,8 +888,8 @@
     for ( i = 0; i < matvar->rank; i++ )
         nmemb *= matvar->dims[i];
 
-    if ( index < nmemb )
-        cell = *((matvar_t **)matvar->data + index);
+    if ( ind < nmemb )
+        cell = *((matvar_t **)matvar->data + ind);
 
     return cell;
 }
@@ -977,7 +978,7 @@
  * @returns an array of pointers to the cells
  */
 matvar_t **
-Mat_VarGetCellsLinear(matvar_t *matvar,int start,int stride,int edge)
+Mat_VarGetCellsLinear(matvar_t *matvar,int UNUSED(start),int stride,int edge)
 {
     int i, I = 0;
     matvar_t **cells;
@@ -1109,11 +1110,11 @@
  * value is the index number.
  * @param opt BY_NAME if the name_or_index is the name or BY_INDEX if the index
  * was passed.
- * @param index linear index of the structure to find the field of
+ * @param ind linear index of the structure to find the field of
  * @return Pointer to the Structure Field on success, NULL on error
  */
 matvar_t *
-Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,int opt,int index)
+Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,int opt,int ind)
 {
     int       i, err = 0, nfields, nmemb;
     matvar_t *field = NULL;
@@ -1124,7 +1125,7 @@
 
     nfields = matvar->nbytes / (nmemb*sizeof(matvar_t *));
 
-    if ( index >= nmemb || index < 0)
+    if ( ind >= nmemb || ind < 0)
         err = 1;
 
     if ( !err && (opt == BY_INDEX) ) {
@@ -1135,14 +1136,14 @@
         if ( field_index > nfields || field_index < 1 )
             Mat_Critical("Mat_VarGetStructField: field index out of bounds");
         else
-            field = *((matvar_t **)matvar->data+index*nfields+field_index - 1);
+            field = *((matvar_t **)matvar->data+ind*nfields+field_index - 1);
     } else if ( !err && (opt == BY_NAME) ) {
         char *field_name;
 
         field_name = (char *)name_or_index;
 
         for ( i = 0; i < nfields; i++ ) {
-            field = *((matvar_t **)matvar->data+index*nfields+i);
+            field = *((matvar_t **)matvar->data+ind*nfields+i);
             if ( !strcmp(field->name,field_name) )
                 break;
             else
@@ -1262,7 +1263,7 @@
  * MAT File version must be 5.
  * @ingroup MAT
  * @param matvar Structure matlab variable
- * @param start starting index
+ * @param start starting index (not used)
  * @param stride stride
  * @param edge Number of structures to get
  * @param copy_fields 1 to copy the fields, 0 to just set pointers to them.
@@ -1270,7 +1271,7 @@
  * @returns A new structure with fields indexed from matvar
  */
 matvar_t *
-Mat_VarGetStructsLinear(matvar_t *matvar,int start,int stride,int edge,
+Mat_VarGetStructsLinear(matvar_t *matvar,int UNUSED(start),int stride,int edge,
     int copy_fields)
 {
     int i, I = 0, field, nfields;
@@ -1784,17 +1785,17 @@
  * @ingroup MAT
  * @param mat MAT file to write to
  * @param matvar MAT variable information to write
- * @param compress Whether or not to compress the data
+ * @param comp Whether or not to compress the data
  *        (Only valid for version 5 MAT files and variables with numeric data)
  * @retval 0 on success
  */
 int
-Mat_VarWrite( mat_t *mat, matvar_t *matvar, int compress )
+Mat_VarWrite( mat_t *mat, matvar_t *matvar, int comp )
 {
     if ( mat == NULL || matvar == NULL )
         return -1;
     else if ( mat->version != MAT_FT_MAT4 )
-        Write5(mat,matvar,compress);
+        Write5(mat,matvar,comp);
 
     return 0;
 }
Index: src/inflate.c
===================================================================
--- src/inflate.c	(revision 111)
+++ src/inflate.c	(working copy)
@@ -20,6 +20,7 @@
  *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 #include <stdlib.h>
+#define MATIO_INTERNAL
 #include "matio.h"
 #include "matio_private.h"
 
Index: src/fortran/CMakeLists.txt
===================================================================
--- src/fortran/CMakeLists.txt	(revision 0)
+++ src/fortran/CMakeLists.txt	(revision 0)
@@ -0,0 +1,5 @@
+INCLUDE(FortranCInterface)
+FortranCInterface_HEADER(fortran.h MACRO_NAMESPACE "FC_" FROM_LIBRARY blas[daxpy])
+
+SET(SIZEOF_VOID_P ${SIZEOF_VOID_PTR})
+Configure_File(matio_t.inc.in matio_t.inc IMMEDIATE @ONLY)
Index: src/CMakeLists.txt
===================================================================
--- src/CMakeLists.txt	(revision 0)
+++ src/CMakeLists.txt	(revision 0)
@@ -0,0 +1,42 @@
+SET(HEADERS matio_private.h mat4.h mat5.h matio.h matioConfig.h)
+SET(SRC_FILES mat.c mat4.c mat5.c io.c endian.c read_data.c snprintf.c)
+IF (Z_LIBRARY)
+    SET(SRC_FILES ${SRC_FILES} inflate.c)
+ENDIF()
+
+IF (WIN32)
+    SET(SRC_FILES ${SRC_FILES} matio.rc)
+ENDIF()
+
+IF (ENABLE_FORTRAN)
+    INCLUDE(FortranCInterface)
+    FortranCInterface_HEADER(fortran.h MACRO_NAMESPACE "FC_" FROM_LIBRARY blas[daxpy])
+    SET(SIZEOF_VOID_P ${SIZEOF_VOID_PTR})
+    CONFIGURE_FILE(fortran/matio_t.inc.in fortran/matio_t.inc IMMEDIATE @ONLY)
+    SET(SRC_FILES ${SRC_FILES} fortran/matio_internal.c fortran/matio.f90)
+    #set(HEADERS ${HEADERS} fortran/create.f90 fortran/read_data.f90 fortran/write_data.f90 fortran/write.f90)
+    INCLUDE_DIRECTORIES(fortran ${CMAKE_CURRENT_BINARY_DIR}/fortran)
+ENDIF()
+
+ADD_LIBRARY(matio ${LIB_TYPE} ${SRC_FILES} ${HEADERS})
+
+IF (Z_LIBRARY)
+    TARGET_LINK_LIBRARIES(matio ${Z_LIBRARY})
+ENDIF()
+
+CONFIGURE_FILE(
+    "${CMAKE_CURRENT_SOURCE_DIR}/matioConfig.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/matioConfig.h"
+    IMMEDIATE @ONLY)
+
+# ================
+# = INSTALLATION =
+# ================
+
+INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/matioConfig.h ${CMAKE_CURRENT_SOURCE_DIR}/matio.h
+        DESTINATION include)
+
+INSTALL(TARGETS matio
+        RUNTIME DESTINATION bin
+        LIBRARY DESTINATION lib
+        ARCHIVE DESTINATION lib)
Index: cmake_uninstall.cmake.in
===================================================================
--- cmake_uninstall.cmake.in	(revision 0)
+++ cmake_uninstall.cmake.in	(revision 0)
@@ -0,0 +1,20 @@
+IF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+    MESSAGE(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\"")
+ENDIF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+
+FILE(READ "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt" files)
+STRING(REGEX REPLACE "\n" ";" files "${files}")
+FOREACH(file ${files})
+    MESSAGE(STATUS "Uninstalling \"$ENV{DESTDIR}${file}\"")
+    IF(EXISTS "$ENV{DESTDIR}${file}")
+        EXEC_PROGRAM(
+            "@CMAKE_COMMAND@" ARGS "-E remove \"$ENV{DESTDIR}${file}\""
+            OUTPUT_VARIABLE rm_out
+            RETURN_VALUE rm_retval)
+        IF(NOT "${rm_retval}" STREQUAL 0)
+            MESSAGE(FATAL_ERROR "Problem when removing \"$ENV{DESTDIR}${file}\"")
+        ENDIF(NOT "${rm_retval}" STREQUAL 0)
+    ELSE(EXISTS "$ENV{DESTDIR}${file}")
+        MESSAGE(STATUS "File \"$ENV{DESTDIR}${file}\" does not exist.")
+    ENDIF(EXISTS "$ENV{DESTDIR}${file}")
+ENDFOREACH(file)
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 0)
+++ CMakeLists.txt	(revision 0)
@@ -0,0 +1,207 @@
+SET(PACKAGE_VERSION_MAJOR "1")
+SET(PACKAGE_VERSION_MINOR "3")
+SET(PACKAGE_VERSION_PATCH "4")
+
+SET(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake;${CMAKE_CURRENT_SOURCE_DIR}/cmake/FortranCInterface")
+
+# ===========
+# = Options =
+# ===========
+
+OPTION(ENABLE_FORTRAN "Enable fortran interface to mat library")
+SET(EXTRA_LANGAGE)
+IF (ENABLE_FORTRAN)
+    SET(EXTRA_LANGAGE Fortran)
+    SET(MATIO_FORTRAN TRUE)
+ENDIF()
+
+PROJECT(MATIO C ${EXTRA_LANGAGE})
+
+SET(MATIO_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+SET(MATIO_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
+
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6.4)
+
+SET(MATIO_PLATFORM ${CMAKE_SYSTEM_PROCESSOR}--${CMAKE_SYSTEM_NAME})
+
+INCLUDE(FindLibrary)
+
+# =======================
+# = HANDLE DEFINITTIONS =
+# =======================
+
+INCLUDE(Boolean)
+BOOLEAN(LINUX UNIX AND NOT APPLE)
+BOOLEAN(WINNT WIN32)
+BOOLEAN(SUN XXXX)
+
+# ===========
+# = Options =
+# ===========
+
+OPTION(ENABLE_PROFILE "Turn on profile")
+IF (ENABLE_PROFILE)
+ENDIF()
+
+OPTION(EXTENDED_SP "Enable extended sparse matrix data types not supported in Matlab" ON)
+IF (EXTENDED_SP)
+    SET(EXTENDED_SPARSE 1)
+ENDIF()
+
+INCLUDE (Documentation OPTIONAL)
+IF (BUILD_DOCUMENTATION)
+    ADD_SUBDIRECTORY(doxygen)
+ENDIF()
+
+# =================
+# = Check headers =
+# =================
+
+# Provide stdint.h for windows.
+
+IF (WIN32 AND NOT CYGWIN_INSTALL_PATH)
+    SET(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}/contrib/Windows)
+    INCLUDE_DIRECTORIES(contrib/Windows)
+ENDIF()
+
+INCLUDE(CheckIncludeFile)
+INCLUDE(CheckHeaderSTDC)
+
+CHECK_INCLUDE_FILE(inttypes.h HAVE_INTTYPES_H)
+CHECK_INCLUDE_FILE(stdint.h   HAVE_STDINT_H)
+CHECK_INCLUDE_FILE(strings.h  HAVE_STRINGS_H)
+CHECK_INCLUDE_FILE(ctype.h    HAVE_CTYPE_H)
+CHECK_INCLUDE_FILE(string.h   HAVE_STRING_H)
+CHECK_INCLUDE_FILE(malloc.h   HAVE_MALLOC_H)
+CHECK_HEADER_STDC()
+
+# ===================
+# = Check type size =
+# ===================
+
+INCLUDE(CheckTypeSize)
+SET(TYPES double float long int short char)
+FOREACH(TYPE ${TYPES})
+    string(TOUPPER ${TYPE} TYPE_UPPER)
+    CHECK_TYPE_SIZE(${TYPE} SIZEOF_${TYPE_UPPER})
+    SET(HAVE_${TYPE_UPPER} 1)
+ENDFOREACH()
+CHECK_TYPE_SIZE(void* SIZEOF_VOID_PTR)
+
+SET(TYPES uint8_t uint16_t uint32_t uint64_t int8_t int16_t int32_t int64_t)
+FOREACH(TYPE ${TYPES})
+    string(TOUPPER ${TYPE} TYPE_UPPER)
+    CHECK_TYPE_SIZE(${TYPE} SIZEOF_${TYPE_UPPER})
+    SET(HAVE_MAT_${TYPE_UPPER} 1)
+    IF(NOT "${SIZEOF_${TYPE_UPPER}}")
+        MESSAGE(FATAL_ERROR "Unknown type ${TYPE}")
+    ENDIF()
+ENDFOREACH()
+
+# ===================
+# = Check functions =
+# ===================
+
+INCLUDE(CheckFunctionExists)
+CHECK_FUNCTION_EXISTS(vsnprintf HAVE_VSNPRINTF)
+CHECK_FUNCTION_EXISTS(snprintf  HAVE_SNPRINTF)
+CHECK_FUNCTION_EXISTS(vasprintf HAVE_VASPRINTF)
+CHECK_FUNCTION_EXISTS(asprintf  HAVE_ASPRINTF)
+
+INCLUDE(VA_COPY)
+VA_COPY()
+
+IF (WIN32)
+    SET(LIBRARY_OUTPUT_PATH    "${CMAKE_BINARY_DIR}")
+    SET(EXECUTABLE_OUTPUT_PATH "${CMAKE_BINARY_DIR}")
+ENDIF()
+
+# =========
+# = Z Lib =
+# =========
+
+OPTION(USE_SYSTEM_ZLIB "Use installed zlib if possible" ON)
+MARK_AS_ADVANCED(USE_SYSTEM_ZLIB)
+
+STRING(COMPARE NOTEQUAL "${USE_SYSTEM_ZLIB_STATUS}" "" USE_SYSTEM_ZLIB_STATUS_NOT_EMPTY)
+IF(USE_SYSTEM_ZLIB_STATUS_NOT_EMPTY)
+    STRING(COMPARE NOTEQUAL "${USE_SYSTEM_ZLIB_STATUS}" "${USE_SYSTEM_ZLIB}" RESET)
+ENDIF()
+
+# Store in cache previous value of BUILD_SHARED
+SET(USE_SYSTEM_ZLIB_STATUS "${USE_SYSTEM_ZLIB}" CACHE INTERNAL "Previous system zlib status" FORCE)
+
+IF (${RESET})
+    UNSET(SYSTEM_ZLIB)
+    UNSET(SYSTEM_ZLIB CACHE)
+    UNSET(Z_LIBRARY)
+    UNSET(Z_LIBRARY CACHE)
+ENDIF()
+
+IF (USE_SYSTEM_ZLIB)
+    FIND_LIBRARY(SYSTEM_ZLIB z)
+    IF (SYSTEM_ZLIB)
+        SET(Z_LIBRARY ${SYSTEM_ZLIB} CACHE STRING "TEST")
+    ELSE()
+        SET(USE_LOCAL_ZLIB 1)
+    ENDIF()
+ENDIF()
+
+IF (NOT USE_SYSTEM_ZLIB OR USE_LOCAL_ZLIB)
+    ADD_SUBDIRECTORY(zlib)
+    INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/zlib ${CMAKE_CURRENT_BINARY_DIR}/zlib)
+    IF (NOT BUILD_SHARED)
+        SET(TARGET_SUFFIX -static)
+    ENDIF()
+    SET(Z_LIBRARY zlib)
+ENDIF()
+
+SET(HAVE_ZLIB 1)
+SET(Z_PREFIX)
+
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}/src)
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/src)
+ADD_SUBDIRECTORY(src)
+
+# ==============
+# = pkg-config =
+# ==============
+
+SET(prefix ${CMAKE_INSTALL_PREFIX})
+SET(VERSION ${PACKAGE_VERSION_MAJOR}.${PACKAGE_VERSION_MINOR}.${PACKAGE_VERSION_PATCH})
+SET(exec_prefix "\${prefix}")
+SET(libdir "\${exec_prefix}/lib")
+SET(includedir "\${prefix}/include")
+SET(ZLIB_LIBS ${Z_LIBRARY})
+
+CONFIGURE_FILE(
+    "${CMAKE_CURRENT_SOURCE_DIR}/matio.pc.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/matio.pc"
+    IMMEDIATE @ONLY)
+
+# ===========
+# = Testing =
+# ===========
+OPTION(BUILD_TESTING "Build tests" ON)
+IF (BUILD_TESTING)
+    INCLUDE(CTest)
+    ENABLE_TESTING()
+    ADD_SUBDIRECTORY(test)
+ENDIF()
+
+# =============
+# = Uninstall =
+# =============
+CONFIGURE_FILE(
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+    IMMEDIATE @ONLY)
+
+ADD_CUSTOM_TARGET(uninstall
+    "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")
+
+#-----------------------------------------------
+# packaging
+#-----------------------------------------------
+
+INCLUDE(Packaging)
Index: doxygen/CMakeLists.txt
===================================================================
--- doxygen/CMakeLists.txt	(revision 0)
+++ doxygen/CMakeLists.txt	(revision 0)
@@ -0,0 +1,11 @@
+INCLUDE (Documentation OPTIONAL)
+
+ADD_CUSTOM_TARGET(documentation ALL)
+
+ADD_DEPENDENCIES(documentation doxygen_outputs)
+
+ADD_CUSTOM_TARGET(doxygen_outputs
+                  COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/doxygen.config
+                  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/doxygen.config)
+
+INSTALL(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/html/ DESTINATION share/doc/OpenMEEG/reference)
Index: test/runTest.cmake
===================================================================
--- test/runTest.cmake	(revision 0)
+++ test/runTest.cmake	(revision 0)
@@ -0,0 +1,17 @@
+EXECUTE_PROCESS(COMMAND ${TEST_PROGRAM} ${TEST_ARGS}
+		        RESULT_VARIABLE RESULT
+                OUTPUT_FILE     ${TEST_OUTPUT})
+#                OUTPUT_ERROR    ERROR)
+
+EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E compare_files ${TEST_OUTPUT} ${TEST_REFERENCE}
+                RESULT_VARIABLE RESULT_COMPARE)
+
+MESSAGE("Result " ${RESULT})
+MESSAGE("Result:" ${RESULT_COMPARE})
+
+IF (${RESULT} STREQUAL "0" AND ${RESULT_COMPARE} STREQUAL "0")
+    MESSAGE("Success")
+    EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E remove ${TEST_OUTPUT})
+ELSE()
+    MESSAGE("FAILURE")
+ENDIF()
Index: test/test_snprintf.c
===================================================================
--- test/test_snprintf.c	(revision 111)
+++ test/test_snprintf.c	(working copy)
@@ -1,13 +1,15 @@
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <math.h>
 #include <matio.h>
+#include <matio_private.h>
 
 int main (void)
 {
         char buf1[1024];
         char buf2[1024];
-        char *fp_fmt[] = {
+        const char *fp_fmt[] = {
                 "%1.1f", 
                 "%-1.5f",
                 "%1.5f",
@@ -28,7 +30,7 @@
         double fp_nums[] = { 6442452944.1234, -1.5, 134.21, 91340.2, 341.1234, 203.9, 0.96, 0.996, 
                              0.9996, 1.996, 4.136, 5.030201, 0.00205,
                              /* END LIST */ 0};
-        char *int_fmt[] = {
+        const char *int_fmt[] = {
                 "%-1.5d", 
                 "%1.5d",
                 "%123.9d",
@@ -42,7 +44,7 @@
                 NULL
         };
         long int_nums[] = { -1, 134, 91340, 341, 0203, 0};
-        char *str_fmt[] = {
+        const char *str_fmt[] = {
                 "10.5s",
                 "5.10s",
                 "10.1s",
@@ -55,7 +57,7 @@
                 "%10s",
                 NULL
         };
-        char *str_vals[] = {"hello", "a", "", "a longer string", NULL};
+        const char *str_vals[] = {"hello", "a", "", "a longer string", NULL};
         int x, y;
         int fail = 0;
         int num = 0;
Index: test/test_mat_writesparse.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_writesparse.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_copy.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_copy.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_write_compressed_cell.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write_compressed_cell.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_write_compressed.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write_compressed.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat.c
===================================================================
--- test/test_mat.c	(revision 111)
+++ test/test_mat.c	(working copy)
@@ -455,7 +455,7 @@
     else if ( !strcmp(test,"writesparse") )
         Mat_Help(helptest_writesparse);
     else if ( !strcmp(test,"write_compressed_sparse") )
-        Mat_Help(helptest_writesparse);
+        Mat_Help(helptest_write_compressed_sparse);
     else if ( !strcmp(test,"write_struct") )
         Mat_Help(helptest_write_struct);
     else if ( !strcmp(test,"write_compressed_struct") )
@@ -499,7 +499,7 @@
 #ifdef HAVE_MAT_UINT64_T
     mat_uint64_t ui64[50];
 #endif
-    char *str = "This is a string";
+    const char *str = "This is a string";
     mat_t *mat;
     matvar_t *matvar;
 
@@ -576,7 +576,7 @@
 #ifdef HAVE_MAT_UINT64_T
     mat_uint64_t ui64[50];
 #endif
-    char *str = "This is a string";
+    const char *str = "This is a string";
     mat_t *mat;
     matvar_t *matvar;
 
@@ -726,7 +726,7 @@
     double  data[50]={0.0,};
     float  fdata[50]={0.0,};
     int    idata[50]={0.0,};
-    char  *str = "This is a string";
+    const char  *str = "This is a string";
     int    err = 0, i;
     mat_t     *mat;
     matvar_t **matvar, *struct_matvar, *substruct_matvar;
@@ -782,7 +782,7 @@
     double  data[50]={0.0,};
     float  fdata[50]={0.0,};
     int    idata[50]={0.0,};
-    char  *str = "This is a string";
+    const char  *str = "This is a string";
     int    err = 0, i;
     mat_t     *mat;
     matvar_t **matvar, *struct_matvar, *substruct_matvar;
@@ -1087,7 +1087,7 @@
 {
     mat_t *mat;
     matvar_t *matvar, *field;
-    int index = 1, err = 0;
+    int ind = 1, err = 0;
 
     mat = Mat_Open(file,MAT_ACC_RDONLY);
     if ( mat ) {
@@ -1104,8 +1104,8 @@
                 case '7':
                 case '8':
                 case '9':
-                    index = atoi(fieldname);
-                    field = Mat_VarGetStructField(matvar,&index,BY_INDEX,0);
+                    ind = atoi(fieldname);
+                    field = Mat_VarGetStructField(matvar,&ind,BY_INDEX,0);
                     err = (field == NULL) ? 1 : 0;
                     if ( !err )
                         Mat_VarPrint( field, 0);
@@ -1284,14 +1284,14 @@
 static int
 test_writesparse( void )
 {
-    int dims[2] = {5,10}, err = 0, i;
+    int dims[2] = {5,10}, err = 0;
     double    d[50] = {1,5,7,8,9,11,15,17,18,19,21,25,27,28,29,31,35,37,38,39,
                        41,45,47,48,49};
     mat_int32_t  ir[25] = {0,4,1,2,3,0,4,1,2,3,0,4,1,2,3,0,4,1,2,3,0,4,1,2,3};
     mat_int32_t  jc[11] = {0,2,5,7,10,12,15,17,20,22,25};
     mat_t *mat;
     matvar_t *matvar;
-    sparse_t  sparse = {0,};
+    sparse_t  sparse;
 
     sparse.nzmax = 25;
     sparse.nir   = 25;
@@ -1322,14 +1322,14 @@
 static int
 test_write_compressed_sparse( void )
 {
-    int dims[2] = {5,10}, err = 0, i;
+    int dims[2] = {5,10}, err = 0;
     double    d[50] = {1,5,7,8,9,11,15,17,18,19,21,25,27,28,29,31,35,37,38,39,
                        41,45,47,48,49};
     mat_int32_t  ir[25] = {0,4,1,2,3,0,4,1,2,3,0,4,1,2,3,0,4,1,2,3,0,4,1,2,3};
     mat_int32_t  jc[11] = {0,2,5,7,10,12,15,17,20,22,25};
     mat_t *mat;
     matvar_t *matvar;
-    sparse_t  sparse = {0,};
+    sparse_t  sparse;
 
     sparse.nzmax = 25;
     sparse.nir   = 25;
@@ -1377,10 +1377,10 @@
 
 int main (int argc, char *argv[])
 {
-    char *prog_name = "test_mat";
+    const char *prog_name = "test_mat";
     int   i, k, err = 0, ntests = 0;
     mat_t *mat, *mat2;
-    matvar_t *matvar, *matvar2, *matvar3;
+    matvar_t *matvar;
 
     Mat_LogInit(prog_name);
 
@@ -1393,7 +1393,7 @@
     } else if  ( (argc == 3) && !strcmp(argv[1],"--help") ) {
         help_test(argv[2]);
     } else if  ( (argc == 2) && !strcmp(argv[1],"--version") ) {
-        printf("%s v%d.%d.%d (compiled %s, %s for %s)\n", prog_name,
+        printf("%s v%s.%s.%s (compiled %s, %s for %s)\n", prog_name,
                MATIO_MAJOR_VERSION, MATIO_MINOR_VERSION, MATIO_RELEASE_LEVEL,
                __DATE__, __TIME__, MATIO_PLATFORM );
         exit(EXIT_SUCCESS);
@@ -1575,10 +1575,10 @@
             k++;
             ntests++;
         } else if ( !strcasecmp(argv[k],"sub2ind") ) {
-            int  dims[3] = {256,256,124}, index[3] = {233,74,1};
+            int  dims[3] = {256,256,124}, ind[3] = {233,74,1};
             int  linear_index;
 
-            linear_index = Mat_CalcSingleSubscript(3,dims,index);
+            linear_index = Mat_CalcSingleSubscript(3,dims,ind);
             Mat_Message("%d",linear_index);
             k++;
             ntests++;
Index: test/results/MATIO-copy-writeslab.out
===================================================================
--- test/results/MATIO-copy-writeslab.out	(revision 0)
+++ test/results/MATIO-copy-writeslab.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-ind2sub.out
===================================================================
--- test/results/MATIO-ind2sub.out	(revision 0)
+++ test/results/MATIO-ind2sub.out	(revision 0)
@@ -0,0 +1,2 @@
+233,74,1
+1 of 1 tests completed successfully
Index: test/results/MATIO-sub2ind.out
===================================================================
--- test/results/MATIO-sub2ind.out	(revision 0)
+++ test/results/MATIO-sub2ind.out	(revision 0)
@@ -0,0 +1,2 @@
+18920
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-i16.out
===================================================================
--- test/results/MATIO-readvar-write-i16.out	(revision 0)
+++ test/results/MATIO-readvar-write-i16.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-str.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-str.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-str.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_struct-1.out
===================================================================
--- test/results/MATIO-getstructfield-write_struct-1.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_struct-1.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-i32.out
===================================================================
--- test/results/MATIO-readvarinfo-write-i32.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-i32.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_struct-2.out
===================================================================
--- test/results/MATIO-getstructfield-write_struct-2.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_struct-2.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_struct-3.out
===================================================================
--- test/results/MATIO-getstructfield-write_struct-3.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_struct-3.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_struct-4.out
===================================================================
--- test/results/MATIO-getstructfield-write_struct-4.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_struct-4.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-writeinf.out
===================================================================
--- test/results/MATIO-writeinf.out	(revision 0)
+++ test/results/MATIO-writeinf.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-writecell.out
===================================================================
--- test/results/MATIO-readvarinfo-writecell.out	(revision 0)
+++ test/results/MATIO-readvarinfo-writecell.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-i8.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-i8.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-i8.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-writecell.out
===================================================================
--- test/results/MATIO-writecell.out	(revision 0)
+++ test/results/MATIO-writecell.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-write.out
===================================================================
--- test/results/MATIO-write.out	(revision 0)
+++ test/results/MATIO-write.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_struct-data.out
===================================================================
--- test/results/MATIO-getstructfield-write_struct-data.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_struct-data.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-i32.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-i32.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-i32.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-d.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-d.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-d.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readslab-d.out
===================================================================
--- test/results/MATIO-readslab-d.out	(revision 0)
+++ test/results/MATIO-readslab-d.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-copy-writeinf.out
===================================================================
--- test/results/MATIO-copy-writeinf.out	(revision 0)
+++ test/results/MATIO-copy-writeinf.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-f.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-f.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-f.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readslab-f.out
===================================================================
--- test/results/MATIO-readslab-f.out	(revision 0)
+++ test/results/MATIO-readslab-f.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-ui64.out
===================================================================
--- test/results/MATIO-readvar-write-ui64.out	(revision 0)
+++ test/results/MATIO-readvar-write-ui64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-write.out
===================================================================
--- test/results/MATIO-copy-write.out	(revision 0)
+++ test/results/MATIO-copy-write.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-copy-writecell.out
===================================================================
--- test/results/MATIO-copy-writecell.out	(revision 0)
+++ test/results/MATIO-copy-writecell.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readslab-i.out
===================================================================
--- test/results/MATIO-readslab-i.out	(revision 0)
+++ test/results/MATIO-readslab-i.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-i16.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-i16.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-i16.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-i64.out
===================================================================
--- test/results/MATIO-readvar-write-i64.out	(revision 0)
+++ test/results/MATIO-readvar-write-i64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_compressed.out
===================================================================
--- test/results/MATIO-copy-write_compressed.out	(revision 0)
+++ test/results/MATIO-copy-write_compressed.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-writenan.out
===================================================================
--- test/results/MATIO-writenan.out	(revision 0)
+++ test/results/MATIO-writenan.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-write_compressed_sparse.out
===================================================================
--- test/results/MATIO-write_compressed_sparse.out	(revision 0)
+++ test/results/MATIO-write_compressed_sparse.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-str.out
===================================================================
--- test/results/MATIO-readvarinfo-write-str.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-str.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-writenan.out
===================================================================
--- test/results/MATIO-copy-writenan.out	(revision 0)
+++ test/results/MATIO-copy-writenan.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-ui64.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-ui64.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-ui64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_compressed_sparse.out
===================================================================
--- test/results/MATIO-copy-write_compressed_sparse.out	(revision 0)
+++ test/results/MATIO-copy-write_compressed_sparse.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-i8.out
===================================================================
--- test/results/MATIO-readvarinfo-write-i8.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-i8.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-str.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-str.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-str.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-i32.out
===================================================================
--- test/results/MATIO-readvar-write-i32.out	(revision 0)
+++ test/results/MATIO-readvar-write-i32.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-writesparse.out
===================================================================
--- test/results/MATIO-writesparse.out	(revision 0)
+++ test/results/MATIO-writesparse.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-d.out
===================================================================
--- test/results/MATIO-readvarinfo-write-d.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-d.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed_cell.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed_cell.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed_cell.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-f.out
===================================================================
--- test/results/MATIO-readvarinfo-write-f.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-f.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-i64.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-i64.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-i64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-writecell.out
===================================================================
--- test/results/MATIO-readvar-writecell.out	(revision 0)
+++ test/results/MATIO-readvar-writecell.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-write_compressed_cell.out
===================================================================
--- test/results/MATIO-write_compressed_cell.out	(revision 0)
+++ test/results/MATIO-write_compressed_cell.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-i8.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-i8.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-i8.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-writecompressed.out
===================================================================
--- test/results/MATIO-writecompressed.out	(revision 0)
+++ test/results/MATIO-writecompressed.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-copy-writesparse.out
===================================================================
--- test/results/MATIO-copy-writesparse.out	(revision 0)
+++ test/results/MATIO-copy-writesparse.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-d.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-d.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-d.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-f.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-f.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-f.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_compressed_cell.out
===================================================================
--- test/results/MATIO-copy-write_compressed_cell.out	(revision 0)
+++ test/results/MATIO-copy-write_compressed_cell.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-i16.out
===================================================================
--- test/results/MATIO-readvarinfo-write-i16.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-i16.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-writenull.out
===================================================================
Index: test/results/TEST_SNPRINTF.out
===================================================================
--- test/results/TEST_SNPRINTF.out	(revision 0)
+++ test/results/TEST_SNPRINTF.out	(revision 0)
@@ -0,0 +1,4 @@
+Testing snprintf format codes against system sprintf...
+0 tests failed out of 285.
+seeing how many digits we support
+we seem to support 18 digits
Index: test/results/MATIO-readvar-write_compressed-i16.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-i16.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-i16.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-write_struct.out
===================================================================
--- test/results/MATIO-write_struct.out	(revision 0)
+++ test/results/MATIO-write_struct.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_struct.out
===================================================================
--- test/results/MATIO-copy-write_struct.out	(revision 0)
+++ test/results/MATIO-copy-write_struct.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_compressed_struct-1.out
===================================================================
--- test/results/MATIO-getstructfield-write_compressed_struct-1.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_compressed_struct-1.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write_compressed-i32.out
===================================================================
--- test/results/MATIO-readvarinfo-write_compressed-i32.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write_compressed-i32.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_compressed_struct-2.out
===================================================================
--- test/results/MATIO-getstructfield-write_compressed_struct-2.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_compressed_struct-2.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_compressed_struct-3.out
===================================================================
--- test/results/MATIO-getstructfield-write_compressed_struct-3.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_compressed_struct-3.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_compressed_struct-4.out
===================================================================
--- test/results/MATIO-getstructfield-write_compressed_struct-4.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_compressed_struct-4.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-ui64.out
===================================================================
--- test/results/MATIO-readvarinfo-write-ui64.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-ui64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-getstructfield-write_compressed_struct-data.out
===================================================================
--- test/results/MATIO-getstructfield-write_compressed_struct-data.out	(revision 0)
+++ test/results/MATIO-getstructfield-write_compressed_struct-data.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-str.out
===================================================================
--- test/results/MATIO-readvar-write-str.out	(revision 0)
+++ test/results/MATIO-readvar-write-str.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-write_compressed_struct.out
===================================================================
--- test/results/MATIO-write_compressed_struct.out	(revision 0)
+++ test/results/MATIO-write_compressed_struct.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-ui64.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-ui64.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-ui64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvarinfo-write-i64.out
===================================================================
--- test/results/MATIO-readvarinfo-write-i64.out	(revision 0)
+++ test/results/MATIO-readvarinfo-write-i64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-i8.out
===================================================================
--- test/results/MATIO-readvar-write-i8.out	(revision 0)
+++ test/results/MATIO-readvar-write-i8.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_compressed_struct.out
===================================================================
--- test/results/MATIO-copy-write_compressed_struct.out	(revision 0)
+++ test/results/MATIO-copy-write_compressed_struct.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-writeslab.out
===================================================================
--- test/results/MATIO-writeslab.out	(revision 0)
+++ test/results/MATIO-writeslab.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-copy-write_null.out
===================================================================
--- test/results/MATIO-copy-write_null.out	(revision 0)
+++ test/results/MATIO-copy-write_null.out	(revision 0)
@@ -0,0 +1 @@
+1 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-d.out
===================================================================
--- test/results/MATIO-readvar-write-d.out	(revision 0)
+++ test/results/MATIO-readvar-write-d.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write-f.out
===================================================================
--- test/results/MATIO-readvar-write-f.out	(revision 0)
+++ test/results/MATIO-readvar-write-f.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed_cell.out
===================================================================
--- test/results/MATIO-readvar-write_compressed_cell.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed_cell.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/results/MATIO-readvar-write_compressed-i64.out
===================================================================
--- test/results/MATIO-readvar-write_compressed-i64.out	(revision 0)
+++ test/results/MATIO-readvar-write_compressed-i64.out	(revision 0)
@@ -0,0 +1 @@
+0 of 1 tests completed successfully
Index: test/test_mat_write_compressed_struct.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write_compressed_struct.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_write.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_writecell.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_writecell.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_write_compressed_sparse.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write_compressed_sparse.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/test_mat_writeslab.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_writeslab.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: test/CMakeLists.txt
===================================================================
--- test/CMakeLists.txt	(revision 0)
+++ test/CMakeLists.txt	(revision 0)
@@ -0,0 +1,103 @@
+IF(NOT WIN32)
+    SET(MATIO_EXTERNAL_LIBRARIES m) 
+ENDIF()
+
+ADD_EXECUTABLE(test_mat test_mat.c)
+TARGET_LINK_LIBRARIES(test_mat matio ${MATIO_EXTERNAL_LIBRARIES})
+
+ADD_EXECUTABLE(test_snprintf test_snprintf.c ${MATIO_SOURCE_DIR}/src/snprintf.c)
+TARGET_LINK_LIBRARIES(test_snprintf ${MATIO_EXTERNAL_LIBRARIES})
+
+MACRO(MATIO_TEST NAME PROG_NAME)
+    SET(PROG_ARGS ${ARGN})
+    IF (WIN32)
+        SET (TEST_DIR ${EXECUTABLE_OUTPUT_PATH})
+    ELSE ()
+        SET (TEST_DIR ${CMAKE_CURRENT_BINARY_DIR})
+    ENDIF ()
+
+    SET (EXECUTABLE ${TEST_DIR}/${PROG_NAME}${CMAKE_EXECUTABLE_SUFFIX})
+    ADD_TEST(${NAME}-COMPARISON
+             ${CMAKE_COMMAND} -D TEST_PROGRAM=${EXECUTABLE}
+                              -D TEST_ARGS=${PROG_ARGS}
+                              -D TEST_OUTPUT=${TEST_DIR}/${NAME}.out
+                              -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/test/results/${NAME}.out
+                              -P ${MATIO_SOURCE_DIR}/test/runTest.cmake ) # To compare output to reference file
+    ADD_TEST(${NAME} ${EXECUTABLE} ${PROG_ARGS}) # To perform memcheck tests
+    #SET_TESTS_PROPERTIES(${NAME} PROPERTIES DEPENDS ${EXECUTABLE})
+    SET_TESTS_PROPERTIES(${NAME}-COMPARISON PROPERTIES
+                         DEPENDS ${NAME}
+                         PASS_REGULAR_EXPRESSION "Success")
+ENDMACRO()
+
+MATIO_TEST(TEST_SNPRINTF test_snprintf)
+
+SET(MATIO_WRITE_TESTS write writecompressed writesparse write_compressed_sparse
+    write_struct write_compressed_struct writecell write_compressed_cell
+    writeinf writenan writenull writeslab)
+
+FOREACH(arg ${MATIO_WRITE_TESTS})
+    MATIO_TEST(MATIO-${arg} test_mat ${arg})
+ENDFOREACH()
+
+SET(MATIO_IND_TESTS ind2sub sub2ind)
+FOREACH(arg ${MATIO_IND_TESTS})
+    MATIO_TEST(MATIO-${arg} test_mat ${arg})
+ENDFOREACH()
+
+SET(MATIO_FILES write write_compressed writesparse write_compressed_sparse
+    write_struct write_compressed_struct writecell write_compressed_cell
+    writeinf writenan write_null writeslab)
+FOREACH(file ${MATIO_FILES})
+    MATIO_TEST(MATIO-copy-${file} test_mat copy test_mat_${file}.mat ${file}.mat)
+ENDFOREACH()
+
+SET(MATIO_OTHER_FILES writeinf writenan write_null)
+FOREACH(file ${MATIO_FILES})
+    MATIO_TEST(MATIO-copy-${file} test_mat copy test_${file}.mat ${file}.mat)
+ENDFOREACH()
+
+#   Record the output and compare it with stored values ??
+
+SET(MATIO_WRITE_VARS d f i64 ui64 i32 i16 i8 str)
+FOREACH(file write write_compressed)
+    FOREACH(var ${MATIO_WRITE_VARS})
+        MATIO_TEST(MATIO-readvarinfo-${file}-${var} test_mat readvarinfo test_${file}.mat ${var})
+        MATIO_TEST(MATIO-readvar-${file}-${var} test_mat readvar test_${file}.mat ${var})
+    ENDFOREACH()
+ENDFOREACH()
+
+FOREACH(file writecell write_compressed_cell)
+    MATIO_TEST(MATIO-readvarinfo-${file} test_mat readvarinfo test_mat_${file}.mat cell)
+    MATIO_TEST(MATIO-readvar-${file} test_mat readvar test_mat_${file}.mat cell)
+ENDFOREACH()
+
+SET(MATIO_WRITESLAB_VARS d f i)
+FOREACH(var ${MATIO_WRITESLAB_VARS})
+    MATIO_TEST(MATIO-readslab-${var} test_mat readslab test_mat_writeslab.mat ${var})
+ENDFOREACH()
+
+FOREACH(file write_struct write_compressed_struct)
+    FOREACH(field 1 2 3 4 data)
+        MATIO_TEST(MATIO-getstructfield-${file}-${field} test_mat getstructfield test_mat_${file}.mat structure ${var})
+    ENDFOREACH()
+ENDFOREACH()
+
+# Add more tests for these.
+
+SET(MATIO_READ_TESTS readvar4 readslab4)
+
+# Set tests that are expected to fail (TO BE CORRECTED).
+
+SET_TESTS_PROPERTIES(MATIO-writenull PROPERTIES WILL_FAIL TRUE)
+SET_TESTS_PROPERTIES(MATIO-writenull-COMPARISON PROPERTIES WILL_FAIL TRUE)
+SET_TESTS_PROPERTIES(MATIO-copy-write_null PROPERTIES WILL_FAIL TRUE)
+SET_TESTS_PROPERTIES(MATIO-readvarinfo-write_compressed_cell PROPERTIES WILL_FAIL TRUE)
+SET_TESTS_PROPERTIES(MATIO-readvar-write_compressed_cell PROPERTIES WILL_FAIL TRUE)
+
+IF (ENABLE_FORTRAN)
+    INCLUDE_DIRECTORIES(${MATIO_SOURCE_DIR}/src/fortran ${MATIO_BINARY_DIR}/src/fortran)
+    ADD_EXECUTABLE(test_matf test_matf.f90)
+    TARGET_LINK_LIBRARIES(test_matf matio m)
+    # TESTS
+ENDIF()
Index: test/test_mat_write_struct.mat
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: test/test_mat_write_struct.mat
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

